/************************************************************************************
*	Name			SMTPRDOC.PC	convertToChar(vuserdomain,vuserdomain);
*
*	Author			MEDICOM R&D Team, Muscat.
*
*	Purpose			Print document for online Pro*C reports
*					
*	Logic			1. Get Workstation ID
*
*					2. Based on input parameters, decide 
*					   "Print Combination" 
*					   (One-file-to-one-location / One-file-to-many
*					   -locations / 
*					   Many-files-to-one-location / Many-files-to-many
*					   -locations)
*
*					3. For each file to be printed
*
*						3.1 Depending upon "Print Combination", 
*							Fetch file name and/or location type/code
*	
*						3.2 Get routing information
*	
*						3.3 Validate each routed printer
*
*						3.4 For each valid printer, print the report.
*
*					4. End
*
*					5. Return 0 If Success Or 1 If NOT Success.
*
*
*	Notes: -
*	InvokeProcess is duplicated here (Defined in Medprocess.PC).
*	since Medprocess.PC cannot be attached here.
*
*   ==========================================================================
*	Input Parameters							Remarks
*   ==========================================================================
*	1. DB Connect String (User/Password@DBName)	Mandatory
*	2. Session ID								Mandatory
*	3. Facility ID								Mandatory
*	4. Module ID								Mandatory
*	5. File Names to be printed					Mandatory
*	6. Location Types (For Routing)				Mandatory
*	7. Location Codes (For Routing)				Mandatory
*	7. Number of Copies							Mandatory
*	8. Page From								Mandatory
*	9. Page To									Mandatory
*  10. Workstation ID							Mandatory
*  11. Report Out Put Dir						Mandatory
*
*   ====================
*	Modification History  
*   ===============================================================
*	Date		Person		Remarks
*   ===============================================================
*	Apr 28,2003	K S Sundar	Created
*
*	Jun 23,2003 Nanjayan	1. For Downward compatibility, SMRMDUSR.C
*							   has been changed. 
*							   Hence, new version is re-attached.
*
*							2. BVNewVersionYN bind variable was NOT 
*							   initialized. Hence, initialized.
*
*							3. The parameters to GetProfileString
*							   function to read WS_NO from MEDICOM.INI
*							   was wrong. Corrected.
*
*	Sep 16,2003	K S Sundar	1. Calls to RegisterError modified to pass
*								additinal arguments.
*
*	Oct 7,2003	K S Sundar	1. Printer driver name is not required anymore.
*							   Hence, While Invoking SMTLBLCV, printer id is 
*							   passed instead of DriverName.
*							   SMTLBLCV is accordingly modified.
*
*							2. SY_PRINTER_ID.PRINTER_DRIVER can be NULL.
*							   While fetching driver name from driver names using
*							   GETTOKEN procedure, procedure fails. Since, it is 
*							   decided that printer driver will not be used anymore,
*							   call to GETTOKEN procedure for getting printer driver
*							   is removed.
*			
*	Dec 11,2003	K S Sundar	1. If number of copies, that is passed as IN argument,
*							   is > 0, then get_report_properties.number_of_copies
*							   should be ignored.
*
*							2. For offline reports, if routing is not defined, then
*							   print the report to the default printer.
*							   New function GetDefaultPrinter is added.
*
*	Jun 02,2004 K S Sundar	1. Validating printer is done by SMTCKPRI.
*							   SY_PRINT_DRIVER.NUM_OF_PAGES is checked for the validity.
*							   Sometimes, it does not work good.
*							   Hence, instead of checking SY_PRINT_DRIVER.NUM_OF_PAGES,
*							   return value from SMTCKPRI is checked.
*
*	Jul 4,2004  K S Sundar	1. In GetRotuingInfo procedure, to check if the 
*								routing is found or not, we check 
*								length(BVPrinterNames) should be greater than 3.
*
*							2. In ValidatePrinter, if no valid printer is found,
*								return 0 else return 1.
*	Jul 07,2005  Rayilla 	1. envvaridentifcation procedure , to read the userdomain, clientname 
*					   value from Environment variables.
*								 
*					2. convertToChar prodeure , store the LPTSTR value 
*	   				   into varchar Variables.
*                             3. In CITRIX environment WORKSTATION.get_workstation_id will return
*				         Server IP address instead of Client IP address. Hence,
*					   code is added to replace workstation id with client name	,
*					   when client system's User domain is equlant to one of
*					   the domain name in SM_DOMAIN_INFO table.
*
*	Jan 09,2007  Shanmugam	 Issue    :-  No. of copies getting accummulated when .zpl file is printed
*                               		  For Example if no.of copies = 3 then it prints 3 x 3 times. 
*		 			 solution :-  If report output is .zpl then number of copies should be one. 
*                               		  Because, no of copies value will be there in .zpl output file 
*							  as 3 in above example case. 
*					 coding   :-  If reportclass is 'L'(i.e lable (.zpl)) then BVValidNoOfCopy = 1
************************************************************************************/

/*
* Header Files.
*/
#include <windows.h>
#include <process.h>
#include <winspool.h>
#include <malloc.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <debug.h>

# define ONE_FILE_TO_ONE_LOCATION		1		// Print combination (One File -> One Location)
# define ONE_FILE_TO_MANY_LOCATIONS		2		// Print combination (One file -> Many Locations)
# define MANY_FILES_TO_ONE_LOCATION		3		// Print combination (Many Files -> One Location)
# define MANY_FILES_TO_MANY_LOCATIONS	4		// Print combination (Many Files -> Many Locations)
# define BUFSIZE 1024

LPTSTR vuserdomain, vuserdomain, vclientname ; 
DWORD dwRet, dwErr, dwclientname;
STARTUPINFO si;
PROCESS_INFORMATION pi;
BOOL fExist, fSuccess; 
LPTSTR envvar; 


HWND	hwnd;
MSG	msg;
WNDCLASS wndclass;
HANDLE hPrinter;
char *ws;
int  GVPrintCombinations;
int  GVCurrentFileCtr;
int  GVPrinterCtr;
char GVCmd[1024];
char GVPGMName[64];
char GVArguments[512];
char LVFunctionName[30];

int  GVValidPrintersCtr;
int  GVCtr ,i;
int  GVIsProcessSucess;


/*
* Declare functions.
*/
int Process(void);			
int GetRoutingInfo(void);
int ValidatePrinter(void);
int PrintTheDocument(void);
int GetDefaultPrinter(void);			// To get the Default Printer
void convertToChar(char *domain_name, char *client_name);


/*
* Declare Bind variables
*/
EXEC SQL BEGIN DECLARE SECTION;

	varchar BVReportType[2];			// Online / Offline
	varchar BVFunctionName[30];			// For Program Tracing
	varchar BVTraceMsg[1024];			// For Program Tracing	
	varchar BVTracingYN[2];				// For Program Tracing
	varchar BVInteractiveTracingYN[2];	// For Program Tracing
	varchar BVPurgeAlwaysYN[2];			// For Program Tracing
	varchar BVComputerName[16];			// For Program Tracing
	int		BVSeqNo;			        // For Program Tracing

	VARCHAR BVDelimiter[3];
 	VARCHAR BVPrinterIDs[1024];  		// APPPRINT.Get_Routing_Printers Database Procedure
 	VARCHAR BVPrinterNames[1024];  		// APPPRINT.Get_Routing_Printers Database Procedure
	VARCHAR BVPrinterTypes[1024];  		// APPPRINT.Get_Routing_Printers Database Procedure
 	VARCHAR BVQueueNames[1024];  		// APPPRINT.Get_Routing_Printers Database Procedure
 	VARCHAR BVNoOfCopies[100];  		// APPPRINT.Get_Routing_Printers Database Procedure
 	VARCHAR BVErrorText[1024];  		// APPPRINT.Get_Routing_Printers Database Procedure

 	VARCHAR BVPrinterID[64];  			
 	VARCHAR BVPrinterName[64];  		// Printer validation
	VARCHAR BVPrinterType[2];  			// Printer validation
	VARCHAR BVQueueName[64];  			// Printer validation
	
	int		BVNumOfPages;  				// Printer validation
	VARCHAR BVerror_text [200];	
  	VARCHAR BVUidPwd[132];
	varchar BVUserId[31];
  	VARCHAR BVSessionID[64];
	VARCHAR BVPGMDateTime[64];
	VARCHAR BVWorkstationID[64];
 	VARCHAR BVFacilityID[64];
 	VARCHAR BVModuleID[64];
 	VARCHAR BVDocumentID[64];
 	VARCHAR BVOutputFileNames[64]; 
 	VARCHAR BVLocationTypes[64]; 
 	VARCHAR BVLocationCodes[64]; 

 	VARCHAR BVFileName[64]; 
 	VARCHAR BVLocationType[64]; 
 	VARCHAR BVLocationCode[64]; 
	VARCHAR BVPNoOfCopies[4];
	VARCHAR BVPageFrom[4];
	VARCHAR BVPageTo[4];

	VARCHAR BVValidNoOfCopies[100];
	VARCHAR BVNoOfCopy[100];				// Printer validation
	VARCHAR BVValidNoOfCopy[100];

 	VARCHAR BVValidPrinterNames[1024]; 
 	VARCHAR BVValidPrinterName[64]; 

 	VARCHAR BVFileNames[1024];		// For GetToken Database Procedure
 	VARCHAR BVDelimeter[2];   		// For GetToken Database Procedure
 	int		BVTokenNumber;   		// For GetToken Database Procedure
 	VARCHAR BVToken[256];   		// For GetToken Database Procedure
 	int		BVTokenStartPos;   		// For GetToken Database Procedure
 	int		BVTokenEndPos;   		// For GetToken Database Procedure
   	VARCHAR BVNewVersionYN[2];   	// TO check the MEDICOM version
	VARCHAR BVReportOutputDir[120]; // To generate the report file(ZPL)
	VARCHAR BVReportClass[2];		// Either Label 'L' or Report 'R'
 	VARCHAR msg_id[7];
 	VARCHAR msg_text[100];
    VARCHAR sm_domain_name[100];
	VARCHAR v_client_name[100]; 
	VARCHAR cur_domain_name[100];
	
	VARCHAR BVndprinterid[120];   //added for ML-MMOH-CRF-0578
	VARCHAR BVndprintername[120];//added for ML-MMOH-CRF-0578
	VARCHAR BVndqueuename[120];//added for ML-MMOH-CRF-0578
	


EXEC SQL END DECLARE SECTION;

EXEC SQL INCLUDE SQLCA.H;
EXEC SQL INCLUDE SQLDA.H;


/* Win main */
int WINAPI WinMain(HINSTANCE  hInstance,HINSTANCE  hPrevInstance,
    LPSTR  lpCmdLine,int  nShowCmd)
{ 
	
	char sep[3]= ";" ;
	char *LVUIDPwd, *LVSession, *LVFacility ,*LVModule ;
	char *LVDocument, *LVOutputFileNames ,*LVLocationCodes;
	char *LVLocationTypes , *LVNoOfCopies ,*LVPageFrom ,*LVPageTo;
	char *ws;
	char *LVWorkstationID, *LVReportOutputDir;
	char *LVndprinterid;//added for ML-MMOH-CRF-0578
	char *LVStrBuf;
	DWORD mcno = 20;
	int   res = 0;
	struct _stat LVFileStat;
	int LVResult;

	BVUidPwd.arr[0]				= '\0';
	BVSessionID.arr[0]			= '\0';
	BVFacilityID.arr[0]			= '\0';
	BVModuleID.arr[0]			= '\0';
	BVDocumentID.arr[0]			= '\0';
	BVOutputFileNames.arr[0]    = '\0';
	BVLocationTypes.arr[0]		= '\0';
	BVLocationCodes.arr[0]      = '\0';
	BVPNoOfCopies.arr[0]        = '\0';
	BVPageFrom.arr[0]			= '\0';
	BVPageTo.arr[0]				= '\0';
	BVWorkstationID.arr[0]		= '\0';
	BVReportOutputDir.arr[0]	= '\0';
	BVReportClass.arr[0]		= '\0';
	
	BVndprinterid.arr[0]	= '\0';//added for ML-MMOH-CRF-0578
	BVndprintername.arr[0]	= '\0';//added for ML-MMOH-CRF-0578
	BVndqueuename.arr[0]	= '\0';//added for ML-MMOH-CRF-0578
	

	BVUidPwd.len				= 0;
	BVSessionID.len				= 0;
	BVFacilityID.len			= 0;
	BVModuleID.len				= 0;
	BVDocumentID.len			= 0;
	BVOutputFileNames.len		= 0;
	BVLocationTypes.len			= 0;
	BVLocationCodes.len			= 0;
	BVPNoOfCopies.len			= 0;
	BVPageFrom.len				= 0;
	BVPageTo.len				= 0;
	BVWorkstationID.len			= 0;
	BVReportOutputDir.len		= 0;
	BVReportClass.len			= 0;
	
	BVndprinterid.arr[0]	= 0;//added for ML-MMOH-CRF-0578
	BVndprintername.arr[0]	= 0;//added for ML-MMOH-CRF-0578
	BVndqueuename.arr[0]	= 0;//added for ML-MMOH-CRF-0578
	

	
	LVUIDPwd			=strtok(lpCmdLine,sep);
	LVSession			=strtok(NULL,sep);
	LVFacility			=strtok(NULL,sep);
	LVModule			=strtok(NULL,sep);
	LVDocument			=strtok(NULL,sep);
	LVOutputFileNames	=strtok(NULL,sep);
	LVLocationTypes		=strtok(NULL,sep);
	LVLocationCodes		=strtok(NULL,sep);
	LVNoOfCopies		=strtok(NULL,sep);
	LVPageFrom			=strtok(NULL,sep);
	LVPageTo			=strtok(NULL,sep);
	LVWorkstationID		=strtok(NULL,sep);
	LVReportOutputDir	=strtok(NULL,sep);
	
	LVndprinterid	=strtok(NULL,sep);//added for ML-MMOH-CRF-0578
	

	strcpy(BVUidPwd.arr,LVUIDPwd);
	BVUidPwd.len = strlen(BVUidPwd.arr);

	strcpy(BVSessionID.arr,LVSession);
	BVSessionID.len = strlen(BVSessionID.arr);

	strcpy(BVFacilityID.arr,LVFacility);
	BVFacilityID.len = strlen(BVFacilityID.arr);

	strcpy(BVModuleID.arr,LVModule);
	BVModuleID.len = strlen(BVModuleID.arr);

	strcpy(BVDocumentID.arr,LVDocument);
	BVDocumentID.len = strlen(BVDocumentID.arr);

	strcpy(BVOutputFileNames.arr,LVOutputFileNames);
	BVOutputFileNames.len = strlen(BVOutputFileNames.arr);

	strcpy(BVLocationTypes.arr,LVLocationTypes);
	BVLocationTypes.len = strlen(BVLocationTypes.arr);

	strcpy(BVLocationCodes.arr,LVLocationCodes);
	BVLocationCodes.len = strlen(BVLocationCodes.arr);

	strcpy(BVPNoOfCopies.arr,LVNoOfCopies);
	BVPNoOfCopies.len = strlen(BVPNoOfCopies.arr);

	strcpy(BVPageFrom.arr,LVPageFrom);
	BVPageFrom.len = strlen(BVPageFrom.arr);

	strcpy(BVPageTo.arr,LVPageTo);
	BVPageTo.len = strlen(BVPageTo.arr);

	if (LVWorkstationID == NULL)
	{
		strcpy(BVWorkstationID.arr,"$#@#$");
		strcpy(BVReportOutputDir.arr,"$#@#$");
	}
	else
	{
		strcpy(BVWorkstationID.arr,LVWorkstationID);
		strcpy(BVReportOutputDir.arr,LVReportOutputDir);
	}
	BVWorkstationID.len = strlen(BVWorkstationID.arr);
	BVReportOutputDir.len = strlen(BVReportOutputDir.arr);
	
	
	
	//added for ML-MMOH-CRF-0578
	if (LVndprinterid > 0)
	{
	strcpy(BVndprinterid.arr,LVndprinterid);
	BVndprinterid.len = strlen(BVndprinterid.arr);
	}
	//end ML-MMOH-CRF-0578
	
	

	/* Added by aparna to handle NULL location codes */

	if (strcmp(BVLocationCodes.arr,"~") == 0)		
	    BVLocationCodes.arr[0]        = '\0'; 

	/* Create Window*/
	
	wndclass.style			= CS_HREDRAW | CS_VREDRAW;
	wndclass.lpfnWndProc    = NULL;
	wndclass.cbClsExtra		= 0;
	wndclass.cbWndExtra		= 0;
	wndclass.hInstance		= hInstance;
	wndclass.hIcon			= NULL;  //LoadIcon ( NULL, IDI_APPLICATION );
	wndclass.hCursor		= NULL;  //LoadCursor ( NULL, IDC_ARROW);
	wndclass.hbrBackground	= GetStockObject (WHITE_BRUSH);
	wndclass.lpszMenuName	= NULL;
	wndclass.lpszClassName	= "Printing Pc";
	RegisterClass ( &wndclass );

	hwnd = CreateWindow("Online Printing",(LPSTR)NULL,
                         WS_POPUP | WS_DLGFRAME,170,190,300,100,
                         (HWND)NULL,(HMENU)NULL,(HANDLE)hInstance,
						 (LPSTR) lpCmdLine);

	/* End of Create Window */


	/*
	* Connect Database.
	*/
	EXEC SQL CONNECT :BVUidPwd;	
	if(sqlca.sqlcode < 0)
	{
		MessageBox(hwnd,"Unable to connect to oracle.","Error",MB_OK|MB_ICONSTOP);
		exit(0);
	}

	set_meduser_role();

	/*
	* Enable or disable tracing.
	*/
	strcpy(GVProgramID,"SMTPRDOC");
	EnableOrDisableTracing();

	/*
	* Write parameter values into tracing.
	*/
	if (IS_TRACING)
	{
		strcpy(LVFunctionName,"WinMain");
		Trace(LVFunctionName,"Begin");

		LVResult = _stat(_pgmptr, &LVFileStat);
		if (LVResult == 0)
		{	
			LVStrBuf = strtok(ctime( &LVFileStat.st_mtime ),"\n");	
			sprintf(GVTraceMsg,"File Name=[%Fs]  TimeStamp=[%s]  Size=[%ld Bytes]", _pgmptr, LVStrBuf , LVFileStat.st_size );
			Trace(LVFunctionName,GVTraceMsg);
		}

		sprintf(GVTraceMsg,"PUidPwd=[%s]  PSessionID=[%s] PFacilityID=[%s]",
				BVUidPwd.arr,BVSessionID.arr,BVFacilityID.arr);
		Trace(LVFunctionName,GVTraceMsg);

		sprintf(GVTraceMsg,"PModuleID=[%s]  PDocumentID=[%s] PFileNames=[%s] PLocationTypes=[%s] PLocationCodes=[%s]",
				BVModuleID.arr,BVDocumentID.arr,BVOutputFileNames.arr,BVLocationTypes.arr,BVLocationCodes.arr);
		Trace(LVFunctionName,GVTraceMsg);
		
		sprintf(GVTraceMsg,"PNumOfCopies=[%s]  PPageFrom=[%s] PPageTo=[%s] BVWorkstationID=[%s] BVReportOutputDir=[%s]",
				BVPNoOfCopies.arr,BVPageFrom.arr,BVPageTo.arr, BVWorkstationID.arr, BVReportOutputDir.arr);
		Trace(LVFunctionName,GVTraceMsg);
	}

	res = Process();  

	if (IS_TRACING) Trace(LVFunctionName,"End");

	return (res);
}

int Process(void)
{
	char LVFunctionName[30];
	int  LVIsProcessSucess;
	int	 LVProcessReturnCode;
	char LVLISFileName[256];
	char LVZPLFileName[256];
	char *LVToken;
	char LVStrBuf[256];

	if (IS_TRACING) 
	{
		strcpy(LVFunctionName,"Process");
		Trace(LVFunctionName,"Begin");
	}

	/*
	*
	*/
	LVIsProcessSucess = 1;
	GVIsProcessSucess = 1;

	/*
	* Assign "," as delimiter.
	*/
	BVDelimiter.arr[0] = '\0';	
  	strcpy(BVDelimiter.arr,",");
	BVDelimiter.len = strlen(BVDelimiter.arr);

    /*
	*When passed BVWorkstationID is "$#@#$" then worksation id is 
	*fetched here.other wise it uses passed value.
	*/
	if (strcmp(BVWorkstationID.arr,"$#@#$") == 0)
	{
		/*
		* Get the workstation id.
		* This code should be uncommented and corrected ...
		*/		
		BVWorkstationID.arr[0] = '\0';	
		BVWorkstationID.len = 0;
		BVNewVersionYN.arr[0] = '\0';
		BVNewVersionYN.len = 0;
		strcpy(BVNewVersionYN.arr,"N");
		if (IS_TRACING) Trace(LVFunctionName,"Fetching Workstation ID (WORKSTATION.get_workstation_id) ...");
		EXEC SQL EXECUTE 
   		BEGIN 
			IF sm_installation_tab_check THEN
				:BVNewVersionYN := 'Y';
			ELSE
				:BVNewVersionYN := 'N';
			END IF;
		END ;
   		END-EXEC ; 		
		
		if ORACLE_ERROR 
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "sm_installation_tab_check", GVTraceMsg);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 1;
		}
		
		BVNewVersionYN.len = strlen(BVNewVersionYN.arr);

		if (strcmp(BVNewVersionYN.arr,"N") == 0)
		{
			ws=(char*) malloc(17* sizeof(char));
			i=GetPrivateProfileString("Workstation","ws_no","",ws,17,"medicom.ini");
			ws[i]='\0';
			strcpy(BVWorkstationID.arr,ws);
			BVWorkstationID.len = strlen(BVWorkstationID.arr);
			if (IS_TRACING)
			{
				sprintf(GVTraceMsg,"BVWorkstationID From Medicom.ini=[%s]",BVWorkstationID.arr);
				Trace(LVFunctionName,GVTraceMsg);
			}

		}//  if (strcmp(BVNewVersionYN.arr,"N") == 0)
		else
		{
			EXEC SQL EXECUTE 
   			BEGIN 
				WORKSTATION.get_workstation_id
				(
					:BVFacilityID,:BVWorkstationID
				);
			END ;
   			END-EXEC ; 		
			if ORACLE_ERROR 
			{
				sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
				RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "WORKSTATION.get_workstation_id", GVTraceMsg);
				if (IS_TRACING) Trace(LVFunctionName, "End");
				return 1;
			}



			BVWorkstationID.arr[BVWorkstationID.len] = '\0';
			if (IS_TRACING)
			{
				sprintf(GVTraceMsg,"BVWorkstationID From System=[%s]",BVWorkstationID.arr);
				Trace(LVFunctionName,GVTraceMsg);
			}

/* Below code is added to support CITRIX to read client name from  Client name Environment 
	variable from  CITRIX. Added by Rayila. 2nd July 2005 10:47 PM */

/*  Code commented on 14.12.09 as domain checking is reqd only for 4.1			
	envvaridentifcation();
           
	convertToChar(vuserdomain,vclientname);

	v_client_name.arr[v_client_name.len] = '\0';
     
		sprintf(GVTraceMsg,"Current User domain is =[%s]",cur_domain_name.arr);
           	Trace(LVFunctionName,  GVTraceMsg);

		sprintf(GVTraceMsg,"CITRIX client name is =[%s]",v_client_name.arr);
           	Trace(LVFunctionName,  GVTraceMsg);

	  	sm_domain_name.arr[0] = '\0' ;
		   
	EXEC SQL

		SELECT DISTINCT upper(domain_name)
		INTO :sm_domain_name 
		FROM SM_DOMAIN_INFO
		where upper(domain_name) = upper(:cur_domain_name);
    
	EXEC SQL

		SELECT  upper(:cur_domain_name)
		INTO :cur_domain_name
		FROM dual;
		 
	
		if ORACLE_ERROR
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			if (IS_TRACING) 
			Trace(LVFunctionName, GVTraceMsg);
			return 0;
		}
			sm_domain_name.arr[sm_domain_name.len] = '\0';
			cur_domain_name.arr[cur_domain_name.len] = '\0';

			sprintf(GVTraceMsg,"sm_domain name is =[%s]",sm_domain_name.arr);
           		Trace(LVFunctionName,  GVTraceMsg);

			if  (strcmp(cur_domain_name.arr, sm_domain_name.arr) ==0)
			{

			// Nullifying the BVWorkstationID value before copy 

			  	BVWorkstationID.arr[0]	= '\0';

				BVWorkstationID.len = strlen(BVWorkstationID.arr);
				BVWorkstationID.arr[BVWorkstationID.len] = '\0' ;
				
			 	strcpy(BVWorkstationID.arr, v_client_name.arr);
				
				BVWorkstationID.len = strlen(BVWorkstationID.arr);
				BVWorkstationID.arr[BVWorkstationID.len] = '\0' ;

				sprintf(GVTraceMsg,"user domain is equal to one of the domain name so, Application is running in CITRIX");
                		Trace(LVFunctionName,  GVTraceMsg);
			}
            else
			{
			   	sprintf(GVTraceMsg,"user domain is not equal to  any one of the domain name");
                		Trace(LVFunctionName,  GVTraceMsg);

			}

// --- Till here code  is added by Rayilla.
Upto Here */
			/*
			* Fetch report output directory.
			*/
			strcpy (BVErrorText.arr, "$test$");
			BVErrorText.len = strlen (BVErrorText.arr);
			BVErrorText.arr[BVErrorText.len] = '\0';

			BVReportOutputDir.arr[0]			= '\0';
			BVReportOutputDir.len			= 0;
			
			BVndprinterid.arr[0]			= '\0';//added ML-MMOH-CRF-0578
			BVndprinterid.len				=0;//added ML-MMOH-CRF-0578
			
			BVndprintername.arr[0]			= '\0';//added ML-MMOH-CRF-0578
			BVndprintername.len				=0;//added ML-MMOH-CRF-0578
			
			BVndqueuename.arr[0]			= '\0';//added ML-MMOH-CRF-0578
			BVndqueuename.len				=0;//added ML-MMOH-CRF-0578
			

			strcpy (BVUserId.arr, BVUidPwd.arr); 
			strcpy (BVUserId.arr, strtok (BVUserId.arr, "/")); 
			BVUserId.len = strlen (BVUserId.arr);
			BVUserId.arr[BVUserId.len] = '\0';

			if (IS_TRACING)
			{
				sprintf(GVTraceMsg,"Calling get_report_output_directory ... BVUserId=[%s] BVWorkstationID=[%s] ...", BVUserId.arr, BVWorkstationID.arr );
				Trace(LVFunctionName, GVTraceMsg);
			}

			EXEC SQL EXECUTE
			BEGIN
				APPPRINT.get_report_output_directory
				(
					:BVUserId,
					:BVWorkstationID,
					:BVReportOutputDir,
					:BVErrorText
				);
			END;
			END-EXEC;			

			if (ORACLE_ERROR)
			{
				sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
				RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "APPPRINT.get_report_output_directory", GVTraceMsg);
				if (IS_TRACING) Trace(LVFunctionName, "End");
				return 0;
			}

			if (IS_TRACING)
			{
				sprintf(GVTraceMsg,"BVUserId = [%s] BVWorkstationID=[%s]  BVReportOutputDir=[%s]  BVErrorText=[%s]  ",BVUserId.arr,BVWorkstationID.arr,BVReportOutputDir.arr,BVErrorText.arr);
				Trace(LVFunctionName,GVTraceMsg);
			}

			/********************************************************************/
			/*	Check the return value of BVErrorText.arr and if it is	  */
			/*	not equal to the Passed temporary value, raise an error       */
			/********************************************************************/

			BVErrorText.arr[BVErrorText.len] = '\0';
			if ( (BVErrorText.len > 0) && (strcmp (BVErrorText.arr, "$test$")) )
			{
			   sprintf (GVTraceMsg, "Error in Open_log_file (): %s", BVErrorText.arr);
			   MessageBox ( hwnd, GVTraceMsg, "Error", MB_OK|MB_ICONSTOP);
			   exit(0);
			}

			BVReportOutputDir.arr[BVReportOutputDir.len] = '\0';
			if ( (BVReportOutputDir.len > 0) && (!strcmp (BVReportOutputDir.arr, "$test$")) )
			{
			   sprintf (GVTraceMsg, "Report Directory Name not defined for %s Application User and/or %s Workstation",
						BVUserId.arr, BVReportOutputDir.arr);
			   MessageBox ( hwnd, GVTraceMsg, "Error", MB_OK|MB_ICONSTOP);
			   exit(0);
			}

			if (sqlca.sqlcode == 1405 )
			{
				sprintf (GVTraceMsg, "Report Output Directory not defined");
				if (IS_TRACING)
				{
					sprintf(GVTraceMsg,"Report Output Directory not defined");
					Trace(LVFunctionName,GVTraceMsg);
				}
			}

		}

    }//  	if (strcmp(BVWorkstationID.arr,"$#@#$") == 0)

	/*
	* Decide whether to print single file or multiple files
	* PFileNames or PLocationTypes will have "," if
 	*/
 	if (strchr(BVOutputFileNames.arr, ',') == NULL)  
	{
		/* One file */
		if (strchr(BVLocationTypes.arr, ',') == NULL)
			GVPrintCombinations = ONE_FILE_TO_ONE_LOCATION;
		else
			GVPrintCombinations = ONE_FILE_TO_MANY_LOCATIONS;	
	}
	else
	{
		/* Multiple files */
		if (strchr(BVLocationTypes.arr, ',') == NULL)
			GVPrintCombinations = MANY_FILES_TO_ONE_LOCATION;
		else
			GVPrintCombinations = MANY_FILES_TO_MANY_LOCATIONS;	
	}

	if (GVPrintCombinations == ONE_FILE_TO_ONE_LOCATION) 
 	{
		BVFileName.arr[0] = '\0';	

		strcpy(BVFileName.arr,BVOutputFileNames.arr);
  		BVFileName.len = strlen(BVFileName.arr);

		BVLocationType.arr[0] = '\0';
		strcpy(BVLocationType.arr,BVLocationTypes.arr);
  		BVLocationType.len = strlen(BVLocationType.arr);

		BVLocationCode.arr[0] = '\0';
		if (BVLocationCodes.arr != NULL)
	  		strcpy(BVLocationCode.arr,BVLocationCodes.arr);
		BVLocationCode.len = strlen(BVLocationCode.arr);

		sprintf(GVTraceMsg,"ONE_FILE_TO_ONE_LOCATION - BVFileName=[%s] BVLocationType=[%s] BVLocationCode=[%s]",
			BVFileName.arr, BVLocationType.arr, BVLocationCode.arr);
	}
	else if (GVPrintCombinations == ONE_FILE_TO_MANY_LOCATIONS)
	{
		BVFileName.arr[0] = '\0';	
		strcpy(BVFileName.arr,BVOutputFileNames.arr);
  		BVFileName.len = strlen(BVFileName.arr);

		BVLocationTypes.arr[0] = '\0';
		strcpy(BVLocationTypes.arr,BVLocationTypes.arr);
  		BVLocationTypes.len = strlen(BVLocationTypes.arr);

		BVLocationCodes.arr[0] = '\0';
		if (BVLocationCodes.arr != NULL)
	  		strcpy(BVLocationCodes.arr,BVLocationCodes.arr);
		BVLocationCodes.len = strlen(BVLocationCodes.arr);

		sprintf(GVTraceMsg,"ONE_FILE_TO_MANY_LOCATIONS - BVFileName=[%s] BVLocationTypes=[%s] BVLocationCodes=[%s]",
			BVFileName.arr, BVLocationTypes.arr, BVLocationCodes.arr);

	}
	else if (GVPrintCombinations == MANY_FILES_TO_ONE_LOCATION)
	{

		strcpy(GVTraceMsg,"MANY_FILES_TO_ONE_LOCATION");
		BVFileNames.arr[0] = '\0';	
		strcpy(BVFileNames.arr,BVOutputFileNames.arr);
  		BVFileNames.len = strlen(BVFileNames.arr);

		BVLocationType.arr[0] = '\0';
		strcpy(BVLocationType.arr,BVLocationTypes.arr);
  		BVLocationType.len = strlen(BVLocationType.arr);

		BVLocationCode.arr[0] = '\0';
		if (BVLocationCodes.arr != NULL)
	  		strcpy(BVLocationCode.arr,BVLocationCodes.arr);
		BVLocationCode.len = strlen(BVLocationCode.arr);

		sprintf(GVTraceMsg,"MANY_FILES_TO_ONE_LOCATION - BVFileNames=[%s] BVLocationType=[%s] BVLocationCode=[%s]",
			BVFileNames.arr, BVLocationType.arr, BVLocationCode.arr);

 	}
	else if (GVPrintCombinations == MANY_FILES_TO_MANY_LOCATIONS)
	{
		strcpy(GVTraceMsg,"MANY_FILES_TO_MANY_LOCATIONS");

		BVFileNames.arr[0] = '\0';	
		strcpy(BVFileNames.arr,BVOutputFileNames.arr);
  		BVFileNames.len = strlen(BVFileNames.arr);

		BVLocationTypes.arr[0] = '\0';
		strcpy(BVLocationTypes.arr,BVLocationTypes.arr);
  		BVLocationTypes.len = strlen(BVLocationTypes.arr);

		BVLocationCodes.arr[0] = '\0';
		if (BVLocationCodes.arr != NULL)
	  		strcpy(BVLocationCodes.arr,BVLocationCodes.arr);
		BVLocationCodes.len = strlen(BVLocationCodes.arr);

		sprintf(GVTraceMsg,"MANY_FILES_TO_MANY_LOCATIONS - BVFileNames=[%s] BVLocationTypes=[%s] BVLocationCodes=[%s]",
			BVFileNames.arr, BVLocationTypes.arr, BVLocationCodes.arr);

 	}
	if (IS_TRACING) Trace(LVFunctionName,GVTraceMsg);

 	/*
 	* Process each file to be printed.
 	*/
	if (IS_TRACING) Trace(LVFunctionName,"About to process each output file ...");
 	GVCurrentFileCtr = 0;
 	do
 	{
		LVIsProcessSucess = 1;

  		/*
  		* Increment the file ctr to be processed.
  		*/
  		GVCurrentFileCtr = GVCurrentFileCtr + 1;

		/*
		* Assign the token number.
		*/
		BVTokenNumber = GVCurrentFileCtr;

		if (GVPrintCombinations == MANY_FILES_TO_MANY_LOCATIONS)
  		{
			/* Get file name */
			BVFileName.arr[0] = '\0';
	   		EXEC SQL EXECUTE 
   			BEGIN 
    			GetToken
    			(
     				:BVFileNames,
     				:BVDelimiter,
     				:BVTokenNumber,
     				:BVFileName,
     				:BVTokenStartPos,
     				:BVTokenEndPos
    			);
	   		END ;
   			END-EXEC ; 		

			if (ORACLE_ERROR && sqlca.sqlcode != -1405)
			{
				sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
				RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "GetToken", GVTraceMsg);
				LVIsProcessSucess = 0;
				break;
			}
			
			BVFileName.arr[BVFileName.len] = '\0';

			/* Get Location Type */
			BVLocationType.arr[0] = '\0';
	   		EXEC SQL EXECUTE 
   			BEGIN 
    			GetToken
    			(
     				:BVLocationTypes,
     				:BVDelimiter,
     				:BVTokenNumber,
     				:BVLocationType,
     				:BVTokenStartPos,
	     			:BVTokenEndPos
    			);
   			END ;
   			END-EXEC ; 
			if (ORACLE_ERROR && sqlca.sqlcode != -1405) 
			{ 
				sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
				RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "GetToken", GVTraceMsg);
				LVIsProcessSucess = 0;
				break;
			}
			BVLocationType.arr[BVLocationType.len] = '\0';

			/* Get Location Code */
			BVLocationCode.arr[0] = '\0';
	   		EXEC SQL EXECUTE 
   			BEGIN 
    			GetToken
    			(
     				:BVLocationCodes,
     				:BVDelimiter,
     				:BVTokenNumber,
	     			:BVLocationCode,
     				:BVTokenStartPos,
     				:BVTokenEndPos
    			);
   			END ;
   			END-EXEC ; 
			if (ORACLE_ERROR && sqlca.sqlcode != -1405)
			{
				sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
				RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "GetToken", GVTraceMsg);
				LVIsProcessSucess = 0;
				break;
			}
			BVLocationCode.arr[BVLocationCode.len] = '\0';
		
		} /*if (GVPrintCombinations == MANY_FILES_TO_MANY_LOCATIONS) */
  		
		else if (GVPrintCombinations == MANY_FILES_TO_ONE_LOCATION)
		{
			/* Get file name */
			BVFileName.arr[0] = '\0';
	   		EXEC SQL EXECUTE 
   			BEGIN 
    			GetToken
    			(
     				:BVFileNames,
     				:BVDelimiter,
     				:BVTokenNumber,
     				:BVFileName,
     				:BVTokenStartPos,
     				:BVTokenEndPos
    			);
	   		END ;
   			END-EXEC ; 		
			if (ORACLE_ERROR && sqlca.sqlcode != -1405) 
			{
				sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
				RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "GetToken", GVTraceMsg);
				LVIsProcessSucess = 0;
				break;
			}
			BVFileName.arr[BVFileName.len] = '\0';

		} /* else if (GVPrintCombinations == MANY_FILES_TO_ONE_LOCATION) */

  		else if (GVPrintCombinations == ONE_FILE_TO_MANY_LOCATIONS)
  		{
			/* Get Location Type */
			BVLocationType.arr[0] = '\0';
	   		EXEC SQL EXECUTE 
   			BEGIN 
    			GetToken
    			(
     				:BVLocationTypes,
     				:BVDelimiter,
     				:BVTokenNumber,
     				:BVLocationType,
     				:BVTokenStartPos,
	     			:BVTokenEndPos
    			);
   			END ;
   			END-EXEC ; 
			if (ORACLE_ERROR && sqlca.sqlcode != -1405) 
			{
				sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
				RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "GetToken", GVTraceMsg);
				LVIsProcessSucess = 0;
				break;
			}
			BVLocationType.arr[BVLocationType.len] = '\0';

			/* Get Location Code */
			BVLocationCode.arr[0] = '\0';
	   		EXEC SQL EXECUTE 
   			BEGIN 
    			GetToken
    			(
     				:BVLocationCodes,
     				:BVDelimiter,
     				:BVTokenNumber,
	     			:BVLocationCode,
     				:BVTokenStartPos,
     				:BVTokenEndPos
    			);
   			END ;
   			END-EXEC ; 
			if (ORACLE_ERROR && sqlca.sqlcode != -1405) 
			{
				sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
				RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "GetToken", GVTraceMsg);
				LVIsProcessSucess = 0;
				break;
			}
			BVLocationCode.arr[BVLocationCode.len] = '\0';

		} /* else if (GVPrintCombinations == ONE_FILE_TO_MANY_LOCATIONS) */

		/*
		* Exit if LVCurrentCtr > 1 when combination is ONE_FILE_TO_ONE_LOCATION
		*/
		if ((GVPrintCombinations == ONE_FILE_TO_ONE_LOCATION) && (GVCurrentFileCtr > 1))
				break;

		/*
		* Exit if no more files and locations.
		*/
		if ((strlen(BVFileName.arr) < 3) && (strlen(BVLocationType.arr) < 3))
			break;

		/*
		* If the processing is succes so far, then
		* get routing info, validate printers and print the document.
		*/
		if (LVIsProcessSucess)
		{
			/*
			* Get routing information.
			*/
			if (GetRoutingInfo())
			{
				/*
				* Validate routed printers.
				*/
				if (ValidatePrinter())
				{
					/*
					* Get report class to determine whether
					* Label Conversion Program is to be invoked or not:
					*/
					BVReportClass.arr[0]	= '\0';
					BVReportClass.len		= 0;

					strcpy (BVErrorText.arr, "$test$");
					BVErrorText.len = strlen (BVErrorText.arr);
					BVErrorText.arr[BVErrorText.len] = '\0';

					if (IS_TRACING)
					{
						sprintf(GVTraceMsg,"Calling appprint.get_report_class BVDocumentID=[%s] BVReportClass[%s] BVErrorText=[%s]", BVDocumentID.arr, BVReportClass.arr, BVErrorText.arr);
						Trace(LVFunctionName,GVTraceMsg);
					}

					EXEC SQL EXECUTE
					BEGIN
						APPPRINT.get_report_class
						(
							:BVDocumentID,
							:BVReportClass,
							:BVErrorText
						);
					END;
					END-EXEC;

					if (ORACLE_ERROR)
					{
						sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
						RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "APPPRINT.get_report_class", GVTraceMsg);
						if (IS_TRACING) Trace(LVFunctionName, "End");
						return 0;
					}

					BVReportClass.arr[BVReportClass.len] = '\0';
					BVErrorText.arr[BVErrorText.len] = '\0';

					if (IS_TRACING)
					{
						sprintf(GVTraceMsg,"BVDocumentID=[%s] BVReportClass=[%s]  BVErrorText=[%s] ",BVDocumentID.arr,BVReportClass.arr,BVErrorText.arr);
						Trace(LVFunctionName,GVTraceMsg);
					}

					if ((BVErrorText.len > 0) && (strcmp (BVErrorText.arr, "$test$")) )
					{
						sprintf (GVTraceMsg, "Error in getting report class [%s]", BVErrorText.arr);
						RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, GVPGMName, GVTraceMsg);
						if (IS_TRACING) Trace(LVFunctionName, "End");
						return 0;
					}

					/*
					* If report class = "Label"
					* and printer type = "Label" then
					* Call SMTLBLCV for label conversion
					*/ 						
				    if ((strcmp(BVReportClass.arr,"L") == 0) && 
				    (strcmp(BVPrinterType.arr,"L") == 0))
					{
						if (IS_TRACING)
						{
							sprintf(GVTraceMsg,"BVReportClass=[%s] BVPrinterID=[%s]",BVReportClass.arr, BVPrinterID.arr);
							Trace(LVFunctionName, GVTraceMsg);
						}

						/*
						* Extract LIS File Name from OutputFileName (Full Path)
						*/
						strcpy(LVStrBuf, BVOutputFileNames.arr);
						LVToken = strtok(LVStrBuf, "\\");
						while(LVToken != NULL )
						{
							/* While there are tokens in "LVStrBuf" */
							/* Get next token: */
							LVToken = strtok(NULL, "\\" );
							if (LVToken != NULL )
							{
								sprintf(LVLISFileName,"%s",LVToken);
							}
						}

						/*
						* Call SMTLBLCV program to convert LIS file to ZPL file
						* SMTCKPRI will set SY_PRINT_DRIVERS.NUM_OF_PAGES to:
						* 1, if LIS file conversion to ZPL file is successfull
						* 0, if LIS file conversion to ZPL file is not successfull
						*/

						strcpy(GVPGMName, "SMTLBLCV");
						sprintf(GVArguments, " %s;%s;%s;%s;%s;%s;%s;%s;%s", 
							BVUidPwd.arr,BVReportOutputDir.arr,LVLISFileName,
							BVPrinterID.arr,BVNoOfCopy.arr,BVFacilityID.arr,
							BVModuleID.arr, BVWorkstationID.arr,BVDocumentID.arr);

						if (IS_TRACING)
						{
							sprintf(GVTraceMsg,"Calling %s%s",GVPGMName, GVArguments);
							Trace(LVFunctionName, GVTraceMsg);
						}
						
						LVProcessReturnCode = InvokeProcess(GVPGMName, GVArguments);
						if (LVProcessReturnCode == 0) 
						{
							/*
							* Formulate ZPL File Name to be printed.
							* BVFileName is used in PrintTheDocument function
							* for actual printing:
							*/
							LVToken = strtok(LVLISFileName, "." );	
							sprintf(LVZPLFileName,"%s%s.ZPL",BVReportOutputDir.arr, LVToken);
							BVFileName.arr[0] = '\0';	
							strcpy(BVFileName.arr,LVZPLFileName);
  							BVFileName.len = strlen(BVFileName.arr);
							
							/*
							* Print document.
							*/							
							if (!PrintTheDocument())
							{
								GVIsProcessSucess = 0;
							}
						}
						else
						{
							if (IS_TRACING) Trace(LVFunctionName, "End");
							exit(0);
						}
				    }// if ((strcmp(BVReportClass.arr,"L") == 0) && 
					else
					{
						/*
						* Print document.
						*/
							
						if (!PrintTheDocument())
						{
							GVIsProcessSucess = 0;
						}
					}
				}// if (ValidatePrinter())			

				
				else // if (!ValidatePrinter())
				{
						GVIsProcessSucess = 0;
				}
			}// if (GetRoutingInfo())
			else // if (!GetRoutingInfo())
			{
				GVIsProcessSucess = 0;
			}
		}// if (LVIsProcessSucess)
		
		else // if (!GetRoutingInfo())
		{
			GVIsProcessSucess = 0;
		}

 	}while(1);

	if (IS_TRACING)
	{
		sprintf(GVTraceMsg,"End GVIsProcessSucess=[%d]", GVIsProcessSucess);
		Trace(LVFunctionName, GVTraceMsg);
	}
	
	if (GVIsProcessSucess)	// If the process for all reports is success,
		return 0;			// Successful Flag
	else
		return 1;			// Unsuccessful Flag
}

int GetRoutingInfo(void)
{
	char LVFunctionName[30];

	if (IS_TRACING) 
	{
		strcpy(LVFunctionName,"GetRoutingInfo");
		Trace(LVFunctionName,"Begin");

		sprintf(GVTraceMsg,"File Ctr=[%d]",GVCurrentFileCtr);
		Trace(LVFunctionName,GVTraceMsg);

		sprintf(GVTraceMsg,"BVFileName=[%s] BVLocationType=[%s] BVLocationCode=[%s]",
			BVFileName.arr, BVLocationType.arr, BVLocationCode.arr);
		Trace(LVFunctionName,GVTraceMsg);
	}

	/*
  	* Call APPPRINT.get_routing_printers database procedure to 
  	* get the routed printer(s) information.
	*/
	BVPrinterIDs.arr[0]	= '\0';
	BVPrinterIDs.len		= 0;
	BVPrinterNames.arr[0]	= '\0';
	BVPrinterNames.len		= 0;
	BVPrinterTypes.arr[0]	= '\0';
	BVPrinterTypes.len		= 0;
	BVQueueNames.arr[0]		= '\0';
	BVQueueNames.len		= 0;
	BVNoOfCopies.arr[0]     = '\0';
	BVNoOfCopies.len		= 0;
	BVErrorText.arr[0]		= '\0';
	BVErrorText.len			= 0;

	if (IS_TRACING) 

	{
		sprintf(GVTraceMsg, "Calling APPPRINT.get_routing_printers BVWorkstationID=[%s] BVFacilityID=[%s] BVModuleID=[%s] BVDocumentID=[%s] BVLocationType=[%s] BVLocationCode=[%s] BVPrinterIDs=[%s] BVPrinterNames=[%s] BVQueueNames=[%s] BVNoOfCopies=[%s]", 
			BVWorkstationID.arr, BVFacilityID.arr, BVModuleID.arr, BVDocumentID.arr, BVLocationType.arr, BVLocationCode.arr, BVPrinterIDs.arr, BVPrinterNames.arr, BVQueueNames.arr , BVNoOfCopies.arr);
		Trace(LVFunctionName,GVTraceMsg);
	}

  	EXEC SQL EXECUTE 
  	BEGIN
		APPPRINT.get_routing_printers
   		(
    		:BVWorkstationID,
    		:BVFacilityID,
    		:BVModuleID,
    		:BVDocumentID,
    		:BVLocationType,
    		:BVLocationCode,
			:BVPrinterIDs,
    		:BVPrinterNames,
			:BVPrinterTypes,
    		:BVQueueNames,
	 	    :BVNoOfCopies,
    		:BVErrorText
   		);
  	END ;
  	END-EXEC ; 
	
	if (ORACLE_ERROR && sqlca.sqlcode != -1405)
	{
		sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
		RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "APPPRINT.get_routing_printers", GVTraceMsg);
		if (IS_TRACING) Trace(LVFunctionName, "End");
		return 0;
	}


/* Add by shanmugam on 22-11-2006	purpose :- if NoOfCopies parameter value is >1, then it takes parameter value, else it takes table value*/
/*code :- if NoOfCopies passed from paratmerter is > 1,then, that value is assigned to the table field variable */

	BVPNoOfCopies.len = strlen(BVPNoOfCopies.arr);
	BVPNoOfCopies.arr[BVPNoOfCopies.len]  = '\0';
	if (atoi(BVPNoOfCopies.arr) > 1)	//Condition checking is changed from 0 to 1 as module is passing default copies as 1
		{
		strcpy(BVNoOfCopies.arr,BVPNoOfCopies.arr);
		}
/* Ends Here */

	BVPrinterIDs.arr[BVPrinterIDs.len]	= '\0';
	BVPrinterNames.arr[BVPrinterNames.len]	= '\0';
	BVPrinterTypes.arr[BVPrinterTypes.len]	= '\0';
	BVQueueNames.arr[BVQueueNames.len]		= '\0';
	BVNoOfCopies.arr[BVNoOfCopies.len]		= '\0';
	BVErrorText.arr[BVErrorText.len]		= '\0';

	/*
	*
	* Dec 11, 2003 - K S Sundar
	* For offline reports, if the routing is not defined. then
	* print the report to the default printer.
	*
	*/
	
	//ADDED FOR ml-mmoh-crf-0578 
	
	if (strlen(BVndprinterid.arr)>0) 
	{
			
		
		EXEC SQL
		SELECT PRINTER_ID||',',PRINTER_NAME||',',QUEUE_NAME||',' 
		INTO   :BVPrinterIDs,:BVPrinterNames,:BVQueueNames
		FROM   SM_PRINTER
		WHERE  PRINTER_ID = :BVndprinterid;
		
		/*strcpy(BVPrinterIDs.arr,strcat(BVndprinterid.arr,","));
		strcpy(BVPrinterNames.arr , strcat(BVndprintername.arr,","));
		strcpy(BVQueueNames.arr , strcat(BVndqueuename.arr,","));*/
		
				
		
		if ORACLE_ERROR
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVPrinterIDs.arr, BVPrinterNames.arr, BVQueueNames.arr,BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr,"Selecting PRINTER_ID,PRINTER_NAME,QUEUE_NAME  from SM_PRINTER", GVTraceMsg);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}
	}
	
	//end ml-mmoh-crf-0578 
	
	if (strlen(BVPrinterNames.arr) < 3)
	{
		/*
		* Is report offline? 
		* Since APPPRINT.get_report_properties
		* is never used in this program, select directly from the table.
		*
		*/
		EXEC SQL
		SELECT NVL(print_immediate_yn,'N')
		INTO   :BVReportType
		FROM   sy_online_print_id
		WHERE  online_print_name = :BVDocumentID;

		if ORACLE_ERROR
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr,"Selecting print_immediate_yn from sy_online_print_id", GVTraceMsg);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}
		BVReportType.arr[BVReportType.len] = '\0';
		
		if (strcmp(BVReportType.arr,"N") == 0)		
		{
			sprintf(GVTraceMsg, "Printer Not defined for %s report,Routing to Default Printer", BVDocumentID.arr);

			if(MessageBox(hwnd,GVTraceMsg,"Confirmation",MB_OKCANCEL|MB_ICONQUESTION|MB_SETFOREGROUND)==IDOK)
			{   
				sprintf(GVTraceMsg,"No routing is defined!! Searching default printer ...");
				if (IS_TRACING) Trace(LVFunctionName,GVTraceMsg);

				GetDefaultPrinter();
			}
		}
		else
		{
			/*
			* Report is online. Routing is not defined.
			*/
			if (IS_TRACING) Trace(LVFunctionName,"End. Report is online and routing is not defined.");
			return 0;
		}
	}

	if (IS_TRACING) 
	{
		sprintf(GVTraceMsg,"BVPrinterIDs=[%s] BVPrinterNames=[%s] BVPrinterTypes=[%s] BVQueueNames=[%s] BVNoOfCopies.arr=[%s] BVErrorText=[%s]",
			BVPrinterIDs.arr, BVPrinterNames.arr, BVPrinterTypes.arr, BVQueueNames.arr, BVNoOfCopies.arr, BVErrorText.arr);
		Trace(LVFunctionName,GVTraceMsg);
	}

	if (IS_TRACING) Trace(LVFunctionName,"End");
	return 1;
}


int ValidatePrinter(void)
{
	char LVFunctionName[30];
	int	 LVProcessReturnCode;

	if (IS_TRACING) 
	{
		strcpy(LVFunctionName,"ValidatePrinter");
		Trace(LVFunctionName,"Begin");
	}

  	/*
  	* Validate the routed printer(s).
  	*/
	GVPrinterCtr				= 1;
	GVValidPrintersCtr			= 0;
	BVValidPrinterNames.arr[0]	= '\0';
	BVValidNoOfCopies.arr[0]	= '\0';
	if (IS_TRACING) Trace(LVFunctionName,"About to validate each of the routed printer ...");
	do
	{
        		
		BVTokenNumber = GVPrinterCtr;    

		/* Intialize */
		BVPrinterName.arr[0]	= '\0';

		/* Get Printer Name from routed printers information */
	   	EXEC SQL EXECUTE 
   		BEGIN 
    		GetToken
    		(
     			:BVPrinterNames,
     			:BVDelimiter,
     			:BVTokenNumber,
     			:BVPrinterName,
     			:BVTokenStartPos,
     			:BVTokenEndPos
    		);
			
			
	   	END ;
   		END-EXEC ; 	
		/* Exit if no more printer names found */
		if (BVTokenEndPos == 0)
			break;
		if ORACLE_ERROR
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "GetToken", GVTraceMsg);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}
		BVPrinterName.arr[BVPrinterName.len] = '\0';

		/*
		* Initialize.
		*/ 
		BVPrinterID.arr[0]	= '\0';
		BVPrinterType.arr[0]	= '\0';
		BVQueueName.arr[0]		= '\0';
		BVNoOfCopy.arr[0]		= '\0';


		/* Get Printer ID from routed printers information */
	   	EXEC SQL EXECUTE 
   		BEGIN 
    		GetToken
    		(
     			:BVPrinterIDs,
     			:BVDelimiter,
     			:BVTokenNumber,
     			:BVPrinterID,
     			:BVTokenStartPos,
     			:BVTokenEndPos
    		);
	   	END ;
   		END-EXEC ; 		
		if ORACLE_ERROR 
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "GetToken", GVTraceMsg);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}
		BVPrinterID.arr[BVPrinterID.len] = '\0';

		/* Get Printer Type from routed printers information */
	   	EXEC SQL EXECUTE 
   		BEGIN 
    		GetToken
    		(
     			:BVPrinterTypes,
     			:BVDelimiter,
     			:BVTokenNumber,
     			:BVPrinterType,
     			:BVTokenStartPos,
     			:BVTokenEndPos
    		);
	   	END ;
   		END-EXEC ; 		
		if ORACLE_ERROR 
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "GetToken", GVTraceMsg);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}
		BVPrinterType.arr[BVPrinterType.len] = '\0';


		/* Get Queue Name from routed printers information */
	   	EXEC SQL EXECUTE 
   		BEGIN 
    		GetToken
    		(
     			:BVQueueNames,
     			:BVDelimiter,
     			:BVTokenNumber,
     			:BVQueueName,
     			:BVTokenStartPos,
     			:BVTokenEndPos
    		);
	   	END ;
   		END-EXEC ; 		
		if ORACLE_ERROR 
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "GetToken", GVTraceMsg);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}
		BVQueueName.arr[BVQueueName.len] = '\0';

		/* Get No of copy from string no_of_copies */
	   	EXEC SQL EXECUTE 
   		BEGIN 
    		GetToken
    		(
     			:BVNoOfCopies,
     			:BVDelimiter,
     			:BVTokenNumber,
     			:BVNoOfCopy,
     			:BVTokenStartPos,
     			:BVTokenEndPos
    		);
	   	END ;
   		END-EXEC ; 		
		if ORACLE_ERROR 
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr, "GetToken", GVTraceMsg);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}
		BVNoOfCopy.arr[BVNoOfCopy.len] = '\0';

		/*
		* Assign Queue Name to Printer Name if Queue Name starts with "\\"
		*/
		if (strncmp(BVQueueName.arr,"\\\\",2) == 0)
		{
			strcpy(BVPrinterName.arr,BVQueueName.arr);
			BVPrinterName.len = strlen(BVPrinterName.arr);
		}

		if (IS_TRACING) 
		{
			sprintf(GVTraceMsg,"Validating - (BVPrinterName=[%s] BVPrinterType=[%s] BVQueueName=[%s])",
				BVPrinterName.arr, BVPrinterType.arr, BVQueueName.arr);
			Trace(LVFunctionName,GVTraceMsg);
		}

		/*
		* Get current date and time.
		*/
		EXEC SQL
		SELECT to_char(sysdate,'ddmmyyyyhh24miss')
		INTO   :BVPGMDateTime
		FROM   dual;
		if ORACLE_ERROR
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr,"Selecting sysdate from dual", GVTraceMsg);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}
		BVPGMDateTime.arr[BVPGMDateTime.len] = '\0';

		/*
		* Insert printer name and queue name to be validated
		* to SY_PRINT_DRIVERS table. This table will be read by SMTCKPRI
		* program to validate the printer.
		*/
		if (IS_TRACING) Trace(LVFunctionName, "Inserting into sy_print_drivers ...");
	    EXEC SQL 
		INSERT INTO sy_print_drivers
		(
			SESSION_ID,
			ADD_DATE_TIME,
			PRINTER_NAME,
			DEST_PORT_NAME,
			NUM_OF_PAGES,
			ERROR_TEXT             
		)
    	VALUES 
		(
			:BVSessionID,					
			:BVPGMDateTime,
			:BVPrinterName,
			:BVQueueName,
			:BVNumOfPages,
			NULL
		);

		EXEC SQL COMMIT;
		if ORACLE_ERROR
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr,"Insert Into SY_print_drivers", GVTraceMsg);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}

		/*
		* Call SMTCKPRI program to validate the printer.
		* SMTCKPRI will set SY_PRINT_DRIVERS.NUM_OF_PAGES to:
		* 1, if printer is valid
		* 0, if printer is invalid.
		*/
		strcpy(GVPGMName, "SMTCKPRI");
		sprintf(GVArguments, " %s %s %s %s", BVUidPwd.arr, BVWorkstationID.arr, BVSessionID.arr, BVPGMDateTime.arr);
		if (IS_TRACING)
		{
			sprintf(GVTraceMsg,"Calling %s%s",GVPGMName, GVArguments);
			Trace(LVFunctionName, GVTraceMsg);
		}
		LVProcessReturnCode = InvokeProcess(GVPGMName, GVArguments);
		if (IS_TRACING)
		{
			sprintf(GVTraceMsg,"Return Code = [%d]", LVProcessReturnCode);
			Trace(LVFunctionName, GVTraceMsg);
		}

		/*
		* Purge SY_PRINT_DRIVERS
		*/
		if (IS_TRACING) Trace(LVFunctionName, "Deleting from sy_print_drivers ...");
		EXEC SQL
		DELETE FROM sy_print_drivers
		WHERE  session_id 	= :BVSessionID
	      	AND    add_date_time 	= :BVPGMDateTime;
		if ORACLE_ERROR 
		{

			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr,"Delete from sy_print_drivers", GVTraceMsg);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}


		/*
		* Check SY_PRINT_DRIVERS.NUM_OF_PAGES (1=Vaid  0=Invalid)
		* Following segment is commented by Sundar on June 02, 2004
		* Now, return value from SMTCKPRI is checked.
		*

		BVerror_text.arr[0]	= '\0';
		BVerror_text.len	= 0;

		if (IS_TRACING) Trace(LVFunctionName, "Selecting from sy_print_drivers ...");
		EXEC SQL
		SELECT	num_of_pages,  error_text
		INTO	BVNumOfPages, BVerror_text
		FROM	sy_print_drivers
		WHERE	session_id 	= :BVSessionID
	        AND	add_date_time 	= :BVPGMDateTime;

		BVerror_text.arr[BVerror_text.len] = '\0';

	    if (ORACLE_ERROR || ORACLE_NODATAFOUND)
		{

			BVNumOfPages = 0;
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr,"Validate Error", BVerror_text.arr);
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}
		*/		

		/*
		* Concatenate Printer name to Valid Printer Names if printer is valid.
		*/
		if (LVProcessReturnCode == 0)		/* Valid Printer */
		{
			if (IS_TRACING) Trace(LVFunctionName, "Printer is VALID");

			GVValidPrintersCtr = GVValidPrintersCtr + 1;

			if (strcmp(BVQueueName.arr,"\\") == 0)
			{
				if (strlen(BVValidPrinterNames.arr) < 2)
					sprintf(BVValidPrinterNames.arr,"%s",BVQueueName.arr);
				else
					sprintf(BVValidPrinterNames.arr,"%s,%s",BVValidPrinterNames.arr,BVQueueName.arr);
			}
			else
			{
				if (strlen(BVValidPrinterNames.arr) < 2)
					sprintf(BVValidPrinterNames.arr,"%s",BVPrinterName.arr);
				else
					sprintf(BVValidPrinterNames.arr,"%s,%s",BVValidPrinterNames.arr,BVPrinterName.arr);
			}
			
			if (strlen(BVValidNoOfCopies.arr) < 1)
			{
				sprintf(BVValidNoOfCopies.arr,"%s",BVNoOfCopy.arr);
			}
			else
			{ 
				sprintf(BVValidNoOfCopies.arr,"%s,%s",BVValidNoOfCopies.arr,BVNoOfCopy.arr);
				
			}
		}
		else /* Invalid Printer */
		{
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr,"ValidatePrinter()", BVerror_text.arr);
			/* 
			*	Even if one printer is invalid, we should return FAIL flag back
			*	to the calling program.
			*/
			GVIsProcessSucess = 0;
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}

		if (IS_TRACING) 
		{
			sprintf(GVTraceMsg, "BVNumOfPages=[%d]",BVNumOfPages);
			Trace(LVFunctionName, GVTraceMsg);
		}

		GVPrinterCtr = GVPrinterCtr + 1;	

	} while (strlen(BVPrinterName.arr) > 0);		
	BVValidPrinterNames.len = strlen(BVValidPrinterNames.arr);
	BVValidNoOfCopies.len = strlen(BVValidNoOfCopies.arr);

	/*
	* 
	* Dec 11, 2003 - K S Sundar
	* If BVValidPrinterNames is NULL And
	*    BVPrinterNames is NOT NULL then
	* BVValidPrinterNames  = BVPrinterNames 
	*
	*/
	if (strcmp(BVValidPrinterNames.arr,"") == 0)		
	{
		if (strcmp(BVPrinterNames.arr,"") != 0)		
		{

			GVValidPrintersCtr			= 1;
			
			strcpy(BVValidPrinterNames.arr,BVPrinterNames.arr);
			BVValidPrinterNames.len = strlen(BVValidPrinterNames.arr);
			
			strcpy(BVValidNoOfCopies.arr,"1");	/* One copy */
			BVValidNoOfCopies.len = strlen(BVValidNoOfCopies.arr);
		}
	}

	if (IS_TRACING) 
	{
		sprintf(GVTraceMsg, "BVValidPrinterNames=[%s] BVValidNoOfCopies=[%s]",
			BVValidPrinterNames.arr, BVValidNoOfCopies.arr);
		Trace(LVFunctionName, GVTraceMsg);
	}

	/*
	* If no valid printer is found, return 0
	* else return 1.
	*/
	if (strlen(BVValidPrinterNames.arr) > 3)
	{
		if (IS_TRACING) Trace(LVFunctionName,"End. Valid printer(s) found.");
		return 1;
	}
	else
	{
		if (IS_TRACING) Trace(LVFunctionName,"End. No valid printer found.");
		return 0;
	}
	
}

int PrintTheDocument(void)
{
	char LVFunctionName[30];
	int	 LVProcessReturnCode;

	if (IS_TRACING) 
	{
		strcpy(LVFunctionName,"PrintTheDocument");
		Trace(LVFunctionName,"Begin");
	}

	/*
  	* Call SMTPRINT to do actual printing for each valid printer.
  	*/ 
	for (GVCtr = 1; GVCtr <= GVValidPrintersCtr; GVCtr ++)
	{
		BVTokenNumber = GVCtr;

		/*
		* Get printer name.
		*/
		BVValidPrinterName.arr[0]   = '\0';
		BVValidPrinterName.len		= 0;
	   	EXEC SQL EXECUTE 
   		BEGIN 
    		GetToken
    		(
     			:BVValidPrinterNames,
     			:BVDelimiter,
     			:BVTokenNumber,
     			:BVValidPrinterName,
     			:BVTokenStartPos,
     			:BVTokenEndPos
    		);
	   	END ;
   		END-EXEC; 		

		if ORACLE_ERROR 
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr,"GetToken", GVTraceMsg);	
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}


		BVValidPrinterName.arr[BVValidPrinterName.len] = '\0';
		if (IS_TRACING)
		{
			sprintf(GVTraceMsg,"BVValidPrinterName=[%s]",BVValidPrinterName.arr);
			Trace(LVFunctionName, GVTraceMsg);
		}

		/*
		* Get No of copy.
		*/
		BVValidNoOfCopy.arr[0] = '\0';
		BVValidNoOfCopy.len = 0;  

		EXEC SQL EXECUTE 
   		BEGIN 
    		GetToken
    		(
     			:BVValidNoOfCopies,
     			:BVDelimiter,
     			:BVTokenNumber,
     			:BVValidNoOfCopy,
     			:BVTokenStartPos,
     			:BVTokenEndPos
    		);
	   	END ;
   		END-EXEC; 		

		if ORACLE_ERROR 
		{
			sprintf(GVTraceMsg,"%s",sqlca.sqlerrm.sqlerrmc);
			RegisterError(BVFacilityID.arr, BVModuleID.arr, BVWorkstationID.arr, BVDocumentID.arr, BVFileName.arr, BVLocationType.arr, BVLocationCode.arr,"", BVPrinterName.arr, BVQueueName.arr,"GetToken", GVTraceMsg);	
			if (IS_TRACING) Trace(LVFunctionName, "End");
			return 0;
		}


		BVValidNoOfCopy.arr[BVValidNoOfCopy.len] = '\0';
		if (IS_TRACING)
		{
			sprintf(GVTraceMsg,"From GetToken procedure BVValidNoOfCopy=[%s]",BVValidNoOfCopy.arr);
			Trace(LVFunctionName, GVTraceMsg);
		}

		/*Added by shanmugam on 09/01/07
			Issue    :-  No. of copies getting accummulated when .zpl file is printed
                               For Example if no.of copies = 3 then it prints 3 x 3 times. 
		 	solution :-  If report output is .zpl then number of copies should be one. 
                               Because, no of copies value will be there in .zpl output file as 3 in above example case. 
			coding   :-  If reportclass is 'L'(i.e lable (.zpl)) then BVValidNoOfCopy = 1*/

		if ((strcmp(BVReportClass.arr,"L") == 0) && 
				    (strcmp(BVPrinterType.arr,"L") == 0))
		{
		strcpy(BVValidNoOfCopy.arr,"1");
		BVValidNoOfCopy.arr[BVValidNoOfCopy.len] = '\0';
		}
		if (IS_TRACING)
		{
			sprintf(GVTraceMsg,"BVReportClass [%s] BVPrinterType [%s] BVValidNoOfCopy [%s]",BVReportClass.arr,BVPrinterType.arr,BVValidNoOfCopy.arr);
			Trace(LVFunctionName, GVTraceMsg);
		}
		/*Ends Here */


		/*
		* Assign " " to BVLocationCode if NULL
		* This is a requirement of SMTPRINT.
		*/
		if (strlen(BVLocationCode.arr) == 0)
		{
			strcpy(BVLocationCode.arr," ");
			BVLocationCode.len = strlen(BVLocationCode.arr);
		}

		if (strlen(BVValidPrinterName.arr) > 0)
		{
			strcpy(GVPGMName, "SMTPRINT");
			strcpy(BVLocationCode.arr," ");
			sprintf
			(
				GVArguments, " %s;%s;%s;%s;%s;%s;%s;%s;%s;%s;%s;%d;%s;%s", 
				BVUidPwd.arr, BVWorkstationID.arr, BVFacilityID.arr, 
				BVModuleID.arr, BVDocumentID.arr, BVFileName.arr,
				BVLocationType.arr, BVLocationCode.arr, 
				BVPrinterID.arr,
				BVValidPrinterName.arr,
				BVQueueName.arr,
				atoi(BVValidNoOfCopy.arr), 
				BVPageFrom.arr, BVPageTo.arr
			);

			if (IS_TRACING)
			{
				sprintf(GVCmd,"Calling %s%s",GVPGMName, GVArguments);
				Trace(LVFunctionName, GVCmd);
			}

			LVProcessReturnCode = InvokeProcess(GVPGMName, GVArguments);
			if (LVProcessReturnCode)	// 1=Success   0=Failure
			{
				if (IS_TRACING) Trace(LVFunctionName, "Command Failed");
				GVIsProcessSucess = 1;	// 1=Success   0=Failure
			}
		}

	} /* for (GVCtr = 1; GVCtr <= GVValidPrintersCtr; GVCtr ++) */
	if (IS_TRACING) Trace(LVFunctionName,"End");
	return GVIsProcessSucess;
}

/*******************************************************************************************
*
* Function 	GetDefaultPrinter
* 
* Author 	K S Sundar
*
* Date 		Dec 11, 2003
*
* Purpose 	To get the default printer.
*
*******************************************************************************************/

int GetDefaultPrinter(void)
{
	char   LVFunctionName[64];
	char   LVDefaultPrinter[250], *LVPrinterName;
	static PRINTER_INFO_2  pInfo[50];
	DWORD  dwReq,dwReturned,dwNeeded,i=0;

	if (IS_TRACING) 
	{
		strcpy(LVFunctionName, "GetDefaultPrinter()"); 
		Trace(LVFunctionName,"Begin");
	}

	i=GetProfileString("Windows","Device","",LVDefaultPrinter,250);
  	LVDefaultPrinter[i]='\0';
	LVPrinterName = strtok(LVDefaultPrinter, ",");

	if (strcmp(LVPrinterName,"") != 0)		
	{
		strcpy(BVPrinterID.arr, "DEFAULT");
		BVPrinterID.len = strlen(BVPrinterID.arr);

		strcpy(BVPrinterNames.arr, LVPrinterName);
		BVPrinterNames.len = strlen(BVPrinterNames.arr);

		strcpy(BVQueueName.arr, LVPrinterName);
		BVQueueName.len = strlen(BVQueueName.arr);

	}


	if (IS_TRACING) 
	{
		sprintf(GVTraceMsg, "Default Printer=[%s]", LVPrinterName); 
		Trace(LVFunctionName,GVTraceMsg);
		Trace(LVFunctionName,"End");
	}
	

	return 1;

}


/*******************************************************************************************
*
* Function 	InvokeProcess
* 
* Author 	K S Sundar
*
* Date 		Dec 17, 2002
*
* Purpose 	Invokes Pro*C application.
*
*******************************************************************************************/

int InvokeProcess(char *PPGMName, char *PArguments)
{
	char LVCmd[1024];
	char LVFunctionName[30];
	int  LVSpawnReturnCode;
	
	if (IS_TRACING)
	{
		strcpy(LVFunctionName,"InvokeProcess");
		Trace(LVFunctionName,"Begin");
	}

	sprintf(LVCmd,"%s%s", PPGMName, PArguments);
	
	if (IS_TRACING) Trace( LVFunctionName, LVCmd);
	
	LVSpawnReturnCode = _spawnlp( _P_WAIT, PPGMName, LVCmd, NULL) ;

	if (IS_TRACING) 
	{
		sprintf(GVTraceMsg,"LVSpawnReturnCode=[%d]",LVSpawnReturnCode);
		Trace( LVFunctionName, GVTraceMsg);

		strcpy(LVFunctionName,"InvokeProcess");
		Trace( LVFunctionName,"End");
	}

	/*
	* LVSpawnReturnCode = 0 Means Success
	* LVSpawnReturnCode = 1 Means Failed
	*/
	return (LVSpawnReturnCode);
}

/* Method is created to Read the environment variables like Userdomain, Client name etc. 
   Created by Rayilla 2nd July 2005 11:08 AM 

 */ 

int envvaridentifcation()
{

// vuserdomain receives the current value of "varname" if it exists.
// It sets "myvar" to a new value, creates a child process, then 
// uses the SetEnvironmentVariable function to restore the original
// value of "myvar" or delete it if it did not exist previously. 
 
vuserdomain = (LPTSTR) malloc(BUFSIZE*sizeof(TCHAR));
vclientname = (LPTSTR) malloc(BUFSIZE*sizeof(TCHAR));

if(NULL == vuserdomain)
{
 
  printf("Out of memory\n");
   return FALSE;
}

dwRet = GetEnvironmentVariable(TEXT("USERDOMAIN"),vuserdomain, BUFSIZE);

dwRet = GetEnvironmentVariable(TEXT("clientname"),vclientname, BUFSIZE);

/*

if(0 == dwRet)
{
   dwErr = GetLastError();
   if( ERROR_ENVVAR_NOT_FOUND == dwErr )
   {
      printf("Environment variable myvar does not exist.\n");
      fExist=FALSE;
   }
}
else if(BUFSIZE < dwRet)
{
   vuserdomain = (LPTSTR) realloc(vuserdomain, dwRet*sizeof(TCHAR));   
   if(NULL == vuserdomain)
   {
      printf("Out of memory\n");
      //return FALSE;
   }
   dwRet = GetEnvironmentVariable(TEXT("path"), vuserdomain, dwRet);
   if(!dwRet)
   {
      printf("GetEnvironmentVariable failed (%d)\n", GetLastError());
      //return FALSE;
   }
   else fExist=TRUE;
}
else fExist=TRUE;

*/

}

 
void convertToChar(char *domain_name, char *client_name)
{
	strcpy(cur_domain_name.arr,domain_name);
	cur_domain_name.len = strlen(cur_domain_name.arr);

	strcpy(v_client_name.arr,client_name);
	v_client_name.len = strlen(v_client_name.arr);
}
