/*******************************************************************************
 * Copyright 1999-2015, Computer Sciences Corporation. All rights reserved.
 *  
 * Warning: This computer program is protected by copyright law and international treaties.
 * Unauthorized reproduction or distribution of this program, or any portion of it, 
 * may result in severe civil and criminal penalties, and will be prosecuted to 
 * the maximum extent possible under the law.
 ******************************************************************************/
package eST.GenerateRequest;

import javax.ejb.SessionContext;
import javax.ejb.EJBException;
import eCommon.Common.*;
import eST.Common.StEJBSessionAdapter;
import java.sql.Connection;
//import java.sql.Date;
import java.sql.PreparedStatement;

import java.sql.SQLException;

import java.util.ArrayList;
import java.util.Properties;
import java.util.HashMap;


/**
*
* @ejb.bean
*	name="GenerateRequest"
*	type="Stateless"
*	transaction-type="Bean"
*	view-type="both"
*	jndi-name="GenerateRequest"
*	local-jndi-name="GenerateRequest"
*	impl-class-name="eST.GenerateRequest.GenerateRequestManager"
*	
*
* @ejb.interface
*	extends="javax.ejb.EJBObject"
*	local-extends="javax.ejb.EJBLocalObject" 
*	local-class="eST.GenerateRequest.GenerateRequestLocal"
*	remote-class="eST.GenerateRequest.GenerateRequestRemote"
*	generate= "local,remote"
*
* @ejb.home
*	extends="javax.ejb.EJBHome" 
*	local-extends="javax.ejb.EJBLocalHome"
*	local-class="eST.GenerateRequest.GenerateRequestLocalHome"
*	remote-class="eST.GenerateRequest.GenerateRequestHome"
*	generate= "local,remote"
*
*
*/


public class  GenerateRequestManager extends StEJBSessionAdapter {

	public SessionContext context = null;
	
	public void setSessionContext( SessionContext sessionContext) {
		super.setSessionContext(sessionContext);
		this.context = sessionContext;
	}
	String sql_sy_acc_entity_doc_type_select;	
	String sql_sy_acc_entity_doc_type_select_flag;


/**
	* @ejb.interface-method
	*	 view-type="both"
	*/

	public HashMap insert(HashMap hmData, HashMap hmSQL) 	{ 
		Connection	connection = null;
		HashMap hmReturn = new HashMap();
		PreparedStatement preparedStatement	=	null;
		String sql =	"";
		ArrayList alData = null;
		ArrayList alRecord = null;
		Properties properties = null;
		ArrayList doc_no	=  new ArrayList();
		boolean isUpdateSuccessful = true;

		int iResult = 0;
		int failedRecordIndex = -1;
		int[] iaResult = null;
		hmReturn.put(RESULT,FALSE);
		String      trn_type		=	"ISS";
		String		doc_no_temp		= "";
		int			sizeOfTrn		=	1;
		int			trnRecords		=	1;
		boolean isAutoNo	=	((String)hmData.get("isAutoNo")).equals("true");

		ArrayList	alDtlData1			=	(ArrayList)	hmData.get("InsertDTLData");
		ArrayList<ArrayList> alTempData		= new ArrayList<ArrayList>();
		ArrayList<Integer> alItemClassCount	= new ArrayList<Integer>();
		String item_class_based	= checkForNull((String)hmData.get("ITEM_CLASS_BASED"),"N");
		alTempData		=	(ArrayList) hmData.get("InsertHDRData");
		if(hmData.containsKey("ItemClassCount")){
			alItemClassCount=	(ArrayList) hmData.get("ItemClassCount");
		}


		try {
			properties =	(Properties) hmData.get("properties");
			connection = getConnection(properties);
			connection.setAutoCommit(false);

			String 	sql_st_records_per_trn_select		=	(String)hmSQL.get ("sql_st_records_per_trn_select");
			HashMap records	=	fetchRecord(connection, sql_st_records_per_trn_select,trn_type);
			int records_per_trn = 0;
			if((String)records.get("RECORDS_PER_TRN")!=null){
				records_per_trn = Integer.parseInt((String)records.get("RECORDS_PER_TRN"));
			}else{
				records_per_trn = alDtlData1.size();
			}
			if(item_class_based.equals("Y")){
				sizeOfTrn = alItemClassCount.size();
			}else{
				if(records_per_trn>alDtlData1.size()){
					sizeOfTrn = 1;
				}else if((alDtlData1.size()%records_per_trn)==0){
					sizeOfTrn = alDtlData1.size()/records_per_trn;
				}else{
					sizeOfTrn = (alDtlData1.size()/records_per_trn)+1;
				}
			}
			if (!isAutoNo ) {
				sizeOfTrn=1;
			}
			sql_sy_acc_entity_doc_type_select		=	(String)hmSQL.get ("sql_sy_acc_entity_doc_type_select");
			sql_sy_acc_entity_doc_type_select_flag	=	(String)hmSQL.get ("sql_sy_acc_entity_doc_type_select_flag");

			// Insert Header Value
			alData =	(ArrayList) hmData.get("InsertHDRData");
			for(int j=0,k=0;j<sizeOfTrn;j++){
				if(item_class_based.equals("Y")){
					alData = new ArrayList();
					alData = alTempData.get(j);

					//isFinalized			=	((String)alHdrData.get(8)).equals("Y");
				}else{
					alData = new ArrayList();
					alData = alTempData;
				}
				/*HashMap hmRecord	=	fetchRecord(connection, sql_sy_acc_entity_doc_type_select_flag, (String)alData.get(1));
				isDocNoAutoGenerated=	hmRecord.get("DOC_NUM_GEN_FLAG").toString().equals("Y");*/

				if (isAutoNo) {
					doc_no_temp = 	(String)fetchRecord(connection, sql_sy_acc_entity_doc_type_select, (String)alData.get(1)).get("NEXT_DOC_NO");
					alData.set(2,doc_no_temp);
				}else{
				doc_no_temp=(String)alData.get(2);
				}
				doc_no.add((String)alData.get(2));
				sql = (String) hmSQL.get	("InsertHDRSQL");
				preparedStatement = connection.prepareStatement(sql);
				setData(preparedStatement,alData);
				iResult = preparedStatement.executeUpdate();

				if(iResult != 0){
					
					hmReturn.put(RESULT,TRUE);
					hmReturn.put(MESSAGE,RECORD_INSERTED);
					
				}
				else {
					connection.rollback();
					throw new EJBException("Insert failed in header");
				}
				
				sql = null;
				alData = null;
			
				if(preparedStatement!=null)
						preparedStatement.close();

				alData = (ArrayList)	hmData.get ("InsertDTLData");
				sql = (String)	hmSQL.get	("InsertDTLSQL");
				preparedStatement = connection.prepareStatement(sql);
				if(item_class_based.equals("Y")){
					trnRecords = k + alItemClassCount.get(j);
				}else{
					if(records_per_trn>alData.size()){
						trnRecords = alData.size();
					}else if((k+records_per_trn)>=alData.size()){
						trnRecords = alData.size();
					}else{
						trnRecords = k+records_per_trn;
					}
				}
				//for (int index=0;i<alData.size() ;index++ ) {
				for (int index = k; index < trnRecords; index++) {
					alRecord = (java.util.ArrayList) alData.get(index);
					alRecord.set(2,doc_no_temp);
					setData(preparedStatement, alRecord);
					preparedStatement.addBatch();
				}
				iaResult = preparedStatement.executeBatch();
				
				for (int i=0;i<iaResult.length ;i++){
					if((iaResult[i] != -2) && (iaResult[i]<0)){
						failedRecordIndex = i;
						isUpdateSuccessful = false;
						break;
					}	
				}
				if(!isUpdateSuccessful){
					connection.rollback();
					throw new EJBException("Update failed while inserting detail record " + failedRecordIndex);
				}

				iaResult = null;
				sql = null;
				alData = null;
			
				if(preparedStatement!=null)
						preparedStatement.close();

				if (hmSQL.containsKey("UpdateSQL") && hmData.containsKey("UpdateData")) {
					sql = (String)	hmSQL.get	("UpdateSQL");
					alData = (ArrayList)	hmData.get ("UpdateData");
					preparedStatement = connection.prepareStatement(sql);
					//for (int index=0;i<alData.size() ;index++ ) {
					for (int index = k; index < trnRecords; index++) {
						alRecord = (java.util.ArrayList) alData.get(index);
						alRecord.set(2,doc_no_temp);
						setData(preparedStatement, alRecord);
						preparedStatement.addBatch();
					}

					iaResult = preparedStatement.executeBatch();

					for (int i=0;i<iaResult.length ;i++){
						if((iaResult[i] != -2) && (iaResult[i]<0)){
							failedRecordIndex = i;
							isUpdateSuccessful = false;
							break;
						}	
					}
					if(!isUpdateSuccessful){
						connection.rollback();
						throw new EJBException("Update failed while inserting detail record " + failedRecordIndex);
					}
				}

				iaResult = null;
				sql = null;
				alData = null;
			
				if(preparedStatement!=null)
						preparedStatement.close();

				
				if (isAutoNo) {
					sql = (String)	hmSQL.get	("UpdateDocNoSQL");
					alData = (ArrayList)	hmData.get ("UpdateDocNoData");
					preparedStatement = connection.prepareStatement(sql);
					setData(preparedStatement,alData);
					iResult = preparedStatement.executeUpdate();
					if(iResult<=0){
						connection.rollback();
						throw new SQLException("Update of Document No failed");
					}
				}
				if(item_class_based.equals("Y")){
					k = k + alItemClassCount.get(j);
				}else{
					k=k+records_per_trn;
				}
			}
			hmReturn.put("doc_no",doc_no);
			connection.commit();
			hmReturn.put(RESULT,TRUE);
			hmReturn.put(MESSAGE,RECORD_INSERTED);
      if (connection!=null) {
					closeConnection(connection,properties);	
	  }
		
		
		}
		catch(SQLException sqlException) {
			
			try {
				connection.rollback();
				hmReturn.put(RESULT,FALSE);
				if(sqlException.getErrorCode()==1)
					hmReturn.put(MESSAGE,CODE_ALREADY_EXISTS);
				else
					hmReturn.put(MESSAGE,sqlException.toString());
				sqlException.printStackTrace();
			}
			catch (Exception exception) {
				exception.printStackTrace(); 
			}
        }
		catch(Exception exception) {
			
			try {
				connection.rollback();
				hmReturn.put(RESULT,FALSE);
				hmReturn.put(MESSAGE,exception.toString());
				exception.printStackTrace();
			}
			catch (Exception subexception) {
				subexception.printStackTrace(); 
			}
        }
		finally{
			
			try{
				if(preparedStatement!=null)
					preparedStatement.close();
				if (connection!=null) {
					closeConnection(connection,(Properties)hmData.get(properties));	
				}
			}
			catch (Exception exception){
				
				exception.printStackTrace();
			}
		}
		
		return hmReturn;
	}
	/**
	* @ejb.interface-method
	*	 view-type="both"
	*/

	public HashMap modify(HashMap hmData, HashMap hmSQL) {
		return getMessageHashMap(false);
	}
	/**
	* @ejb.interface-method
	*	 view-type="both"
	*/


	public HashMap delete( HashMap hmData, HashMap hmSQL )  {
		return getMessageHashMap(false);
	}


}
