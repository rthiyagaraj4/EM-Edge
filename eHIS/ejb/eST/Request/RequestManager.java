/*******************************************************************************
 * Copyright 1999-2015, Computer Sciences Corporation. All rights reserved.
 *  
 * Warning: This computer program is protected by copyright law and international treaties.
 * Unauthorized reproduction or distribution of this program, or any portion of it, 
 * may result in severe civil and criminal penalties, and will be prosecuted to 
 * the maximum extent possible under the law.
 ******************************************************************************/
/*
-------------------------------------------------------------------------------------------------------------------------------
Date		            Edit History	        Name		       Rev.Date		     Rev.Name			     Description
-------------------------------------------------------------------------------------------------------------------------------
06/04/2017				IN063878				Badmavathi B					        					 Unused variables
23/2/2022				TFS27891				Shazana														MO-CRF-20176
-------------------------------------------------------------------------------------------------------------------------------
*/ 
package eST.Request;
import javax.ejb.SessionContext;
import javax.ejb.EJBException;
import eCommon.Common.*;
import eST.Common.StEJBSessionAdapter;
import java.sql.Connection;
//import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
//import java.sql.BatchUpdateException;
import java.sql.SQLException;
//import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Properties;
import java.util.HashMap;
import webbeans.eCommon.* ;

/**
*
* @ejb.bean
*	name="Request"
*	type="Stateless"
*	transaction-type="Bean"
*	view-type="both"
*	jndi-name="Request"
*	local-jndi-name="Request"
*	impl-class-name="eST.Request.RequestManager"
*	
*
* @ejb.interface
*	extends="javax.ejb.EJBObject"
*	local-extends="javax.ejb.EJBLocalObject" 
*	local-class="eST.Request.RequestLocal"
*	remote-class="eST.Request.RequestRemote"
*	generate= "local,remote"
*
* @ejb.home
*	extends="javax.ejb.EJBHome" 
*	local-extends="javax.ejb.EJBLocalHome"
*	local-class="eST.Request.RequestLocalHome"
*	remote-class="eST.Request.RequestHome"
*	generate= "local,remote"
*
*
*/


public class  RequestManager extends StEJBSessionAdapter {
//	public SessionContext context = null;
	public void setSessionContext( SessionContext sessionContext) {
		super.setSessionContext(sessionContext);
		this.context = sessionContext;
	}
	///Function for handling generic operation..
	String sql_sy_acc_entity_doc_type_select;	
	String sql_sy_acc_entity_doc_type_select_flag;

	/**
	* @ejb.interface-method
	*	 view-type="both"
	*/

	public HashMap insert(HashMap hmData, HashMap hmSQL)	{
		Connection	connection = null;
		HashMap hmReturn = new HashMap();
		PreparedStatement preparedStatement	=	null;
		String sql =	"";
		ArrayList alData = null;
		ArrayList alRecord = null;
		Properties properties = null;
		ArrayList doc_no		= new ArrayList();
		String doc_no_temp		= "";
		String trn_type			= "ISS";
		ArrayList alTempData		= new ArrayList();
		ArrayList<Integer> alItemClassCount	= new ArrayList<Integer>();
		String item_class_based	= checkForNull((String)hmData.get("ITEM_CLASS_BASED"),"N");
		alTempData		=	(ArrayList) hmData.get("InsertHDRData");
		if(hmData.containsKey("ItemClassCount")){
			alItemClassCount=	(ArrayList) hmData.get("ItemClassCount");
		}

		//String   trn_type		=	"REQ";
		int      sizeOfTrn		=	1;
		int      trnRecords		=	1;

		boolean isUpdateSuccessful = true;
		boolean isDocNoAutoGenerated	=	false;
		int iResult = 0;
		int failedRecordIndex = -1;
		int[] iaResult = null;
		hmReturn.put(RESULT,FALSE);
		ArrayList	alDtlData1			=	(ArrayList)	hmData.get("InsertDTLData");
		try {
			properties =	(Properties) hmData.get("properties");
			connection = getConnection(properties);
			connection.setAutoCommit(false);


			String 	sql_st_records_per_trn_select		=	(String)hmSQL.get ("sql_st_records_per_trn_select");
			HashMap records	=	fetchRecord(connection, sql_st_records_per_trn_select,trn_type);
			int records_per_trn = 0;
			if((String)records.get("RECORDS_PER_TRN")!=null){
				records_per_trn = Integer.parseInt((String)records.get("RECORDS_PER_TRN"));
			}else{
				records_per_trn = alDtlData1.size();
			}
			//MO-CRF-20176 START
			String		onStore =""; 
			onStore = (String)hmData.get("REQUEST_ON_STORE");//MO-CRF-20176 
			String 	sql_st_store_records_per_trn_select		=	(String)hmSQL.get ("sql_st_store_records_per_trn_select");
			HashMap records1	=	fetchRecord(connection, sql_st_store_records_per_trn_select,onStore);
			int records_per_trn_iss = 0;
			if((String)records1.get("RECORDS_PER_TRN_ISS")!=null){
				records_per_trn_iss = Integer.parseInt((String)records1.get("RECORDS_PER_TRN_ISS"));
			}  
			System.out.println("records_per_trn: "+records_per_trn);
			System.out.println("records_per_trn_iss:"+records_per_trn_iss);
			if(records_per_trn_iss != 0){
				records_per_trn = records_per_trn_iss;
			} //end  
			if(item_class_based.equals("Y")){
				sizeOfTrn = alItemClassCount.size();
			}else{
				if(records_per_trn>alDtlData1.size()){
					sizeOfTrn = 1;
				}else if((alDtlData1.size()%records_per_trn)==0){
					sizeOfTrn = alDtlData1.size()/records_per_trn;
				}else{
					sizeOfTrn = (alDtlData1.size()/records_per_trn)+1;
				}
			}

			sql_sy_acc_entity_doc_type_select		=	(String)hmSQL.get ("sql_sy_acc_entity_doc_type_select");
			sql_sy_acc_entity_doc_type_select_flag	=	(String)hmSQL.get ("sql_sy_acc_entity_doc_type_select_flag");

			// Insert Header Value
			for(int j=0,k=0;j<sizeOfTrn;j++){
			//for(int j=0,k=0;j<alTempData.size();j++){
				if(item_class_based.equals("Y")){
					//alData = new ArrayList();
					alData = (ArrayList)alTempData.get(j);
					//isFinalized			=	((String)alHdrData.get(8)).equals("Y");
				}else{
					alData = alTempData;
				}
				HashMap hmRecord	=	fetchRecord(connection, sql_sy_acc_entity_doc_type_select_flag, (String)alData.get(1));
				isDocNoAutoGenerated=	checkForNull((String)hmRecord.get("DOC_NUM_GEN_FLAG"),"Y").equals("Y");
				ArrayList allanguageData			=	(ArrayList)	hmData.get("LANGUAGE_DATA");
				String locale=(String)allanguageData.get(0);
				
				if (isDocNoAutoGenerated) {
					
					Connection connection111 = ConnectionManager.getConnection();	
					connection111.setAutoCommit(false);
					
					doc_no_temp = 	(String)fetchRecord(connection111, sql_sy_acc_entity_doc_type_select, (String)alData.get(1)).get("NEXT_DOC_NO");
					
					alData.set(2,doc_no_temp);
					doc_no.add(doc_no_temp);
					
					//Update the sy_acc_entity_doc_type with the next number for peformance 9:27 AM 3/27/2010
					
					
					String s  = "";
					String s1 = "";
					sql = (String)	hmSQL.get	("UpdateSQL");
					ArrayList newAlData = (ArrayList)	hmData.get ("UpdateData");
					preparedStatement = connection111.prepareStatement(sql);
					setData(preparedStatement,newAlData);
					iResult = preparedStatement.executeUpdate();
					connection111.commit();
					
					if(doc_no.size()>1){
						java.util.Locale loc = new java.util.Locale(locale);
						java.util.ResourceBundle common_labels = java.util.ResourceBundle.getBundle( "eCommon.resources.Labels",loc);
						s = getSTMessage(locale, "DOC_NOS_GEN_FROM", "ST") ;
					
						s1=s+"  "+doc_no.get(0)+" "+common_labels.getString("Common.to.label")+" "+doc_no.get(doc_no.size()-1);
					}else{
						s = getSTMessage(locale, "DOC_NO", "ST") ;
						s1=s+":  "+doc_no.get(0);
					}
					hmReturn.put("flag",s1);
					if(preparedStatement!=null)
							preparedStatement.close();
							
					
					if(iResult<=0){
						connection111.rollback();
						connection111.close();
						throw new SQLException("Update of Document No failed");
					}else{
						connection111.close();
					}					
				}
				sql = (String) hmSQL.get	("InsertHDRSQL");
				preparedStatement = connection.prepareStatement(sql);
				setData(preparedStatement,alData);
				iResult = preparedStatement.executeUpdate();
				if(preparedStatement!=null)
						preparedStatement.close();
				if(iResult != 0) {
					hmReturn.put(RESULT,TRUE);
					hmReturn.put(MSGID,RECORD_INSERTED);
				}
				else {
					connection.rollback();
					throw new EJBException("Insert failed in header");
				}
				// Insert Detail Value
				sql = null;
				alData = null;
				//preparedStatement = null;
				alData = (ArrayList)	hmData.get ("InsertDTLData");
				sql = (String)	hmSQL.get	("InsertDTLSQL");
				preparedStatement = connection.prepareStatement(sql);
				/*Remove this line*/
				if(item_class_based.equals("Y")){
					trnRecords = k + alItemClassCount.get(j);
				}else{
					if(records_per_trn>alData.size()){
						trnRecords = alData.size();
					}else if((k+records_per_trn)>=alData.size()){
						trnRecords = alData.size();
					}else{
						trnRecords = k+records_per_trn;
					}
				}
				//for (int index=0;i<alData.size() ;index++ ) {
				for (int index = k; index < trnRecords; index++) {
					alRecord = (java.util.ArrayList) alData.get(index);
					alRecord.set(2,doc_no_temp);
					setData(preparedStatement, alRecord);
					preparedStatement.addBatch();
				}
				iaResult = preparedStatement.executeBatch();
				if(preparedStatement!=null)
						preparedStatement.close();
				//preparedStatement.clearParameters();
				for (int i=0;i<iaResult.length ;i++){
					if((iaResult[i] != -2) && (iaResult[i]<0)){
						failedRecordIndex = i;
						isUpdateSuccessful = false;
						break;
					}	
				}
				if(!isUpdateSuccessful){
					connection.rollback();
					throw new EJBException("Update failed while inserting detail record " + failedRecordIndex);
				}
				// Update Item Store
				if (hmSQL.containsKey("UpdateITMSQL") && hmData.containsKey("UpdateITMData")) {
					sql = null;
					alData = null;
				//	preparedStatement = null;
					alData = (ArrayList)	hmData.get ("UpdateITMData");
					sql = (String)	hmSQL.get	("UpdateITMSQL");
					preparedStatement = connection.prepareStatement(sql);
					for (int index = k; index < trnRecords; index++) {
						alRecord = (java.util.ArrayList) alData.get(index);
						setData(preparedStatement, alRecord);
						preparedStatement.addBatch();
					}
					iaResult = preparedStatement.executeBatch();
					if(preparedStatement!=null)
						preparedStatement.close();
					//preparedStatement.clearParameters();
					for (int i=0;i<iaResult.length ;i++){
						if((iaResult[i] != -2) && (iaResult[i]<0)){
							failedRecordIndex = i;
							isUpdateSuccessful = false;
							break;
						}	
					}
					if(!isUpdateSuccessful){
						connection.rollback();
						throw new EJBException("Update failed while inserting detail record " + failedRecordIndex);
					}
				}
				iaResult = null;
				sql = null;
				alData = null;
				//preparedStatement = null;
				//Update the document no
				/*ArrayList allanguageData			=	(ArrayList)	hmData.get("LANGUAGE_DATA");
				String locale=(String)allanguageData.get(0);
				if (isDocNoAutoGenerated) {
					String s  = "";
					String s1 = "";
					sql = (String)	hmSQL.get	("UpdateSQL");
					alData = (ArrayList)	hmData.get ("UpdateData");
					preparedStatement = connection.prepareStatement(sql);
					setData(preparedStatement,alData);
					iResult = preparedStatement.executeUpdate();
					if(doc_no.size()>1){
						java.util.Locale loc = new java.util.Locale(locale);
						java.util.ResourceBundle common_labels = java.util.ResourceBundle.getBundle( "eCommon.resources.Labels",loc);
						s = getSTMessage(locale, "DOC_NOS_GEN_FROM", "ST") ;
					
						s1=s+"  "+doc_no.get(0)+" "+common_labels.getString("Common.to.label")+" "+doc_no.get(doc_no.size()-1);
					}else{
						s = getSTMessage(locale, "DOC_NO", "ST") ;
						s1=s+":  "+doc_no.get(0);
					}
					hmReturn.put("flag",s1);
					if(preparedStatement!=null)
							preparedStatement.close();
					if(iResult<=0){
						connection.rollback();
						throw new SQLException("Update of Document No failed");
					}
				}*/
				// After successful insertion and updation 
				if(item_class_based.equals("Y")){
					k = k + alItemClassCount.get(j);
				}else{
					k=k+records_per_trn;
				}
			}
				connection.commit();
				//connection.rollback();
				hmReturn.put(RESULT,TRUE);
				hmReturn.put(MSGID,RECORD_INSERTED);
				if (connection!=null) {
						closeConnection(connection,properties);	
				}
		}
		catch(SQLException sqlException) {
			try {
				connection.rollback();
				hmReturn.put(RESULT,FALSE);
				if(sqlException.getErrorCode()==1) {
					hmReturn.put(MESSAGE,CODE_ALREADY_EXISTS);
				}
				else {
					hmReturn.put(MESSAGE,sqlException.toString());
					hmReturn.put(MSGID,sqlException.toString());//new added
					hmReturn.put("flag","");//new added
				}
				sqlException.printStackTrace();
			}
			catch (Exception exception) {
				exception.printStackTrace(); 
			}
        }
		catch(Exception exception) {
			try {
				connection.rollback();
				hmReturn.put(RESULT,FALSE);
				hmReturn.put(MESSAGE,exception.toString());
				exception.printStackTrace();
			}
			catch (Exception subexception) {
				subexception.printStackTrace(); 
			}
        }
		finally{
			try{
				if(preparedStatement!=null)
					preparedStatement.close();
				if (connection!=null) {
					closeConnection(connection,(Properties)hmData.get(properties));	
				}
			}
			catch (Exception exception){
				exception.printStackTrace();
			}
		}
		hmReturn.put("doc_no",doc_no);
		return hmReturn;
	}

	/**
	* @ejb.interface-method
	*	 view-type="both"
	*/

	public HashMap modify(HashMap hmData, HashMap hmSQL)	 {
		Connection	connection = null;
		HashMap hmReturn = new HashMap();
		PreparedStatement preparedStatement	=	null;
		ArrayList alData =	new ArrayList();
		ArrayList	 alRecord =	new ArrayList();
		Properties properties = null;
		String sql =	"";
		int iResult =	0;
		int iaResult[] = null;
		boolean isUpdateSuccessful = true;
		hmReturn.put(RESULT,FALSE);
		hmReturn.put(MESSAGE,"No records found to be modified..");
		properties =	(Properties) hmData.get("properties");

		//Added by sakti against ML-BRU-SCF-1091.1 to restrict adding items based on transaction per record
		ArrayList doc_no		= new ArrayList();
		ArrayList alModifyData = null; //19/08
		String doc_no_temp		= "";
		String trn_type			= "ISS";
		ArrayList alTempData		= new ArrayList();
		ArrayList<Integer> alItemClassCount	= new ArrayList<Integer>();
		String item_class_based	= checkForNull((String)hmData.get("ITEM_CLASS_BASED"),"N");
		if(hmData.containsKey("ItemClassCount")){
			alItemClassCount=	(ArrayList) hmData.get("ItemClassCount");
		}
		int      sizeOfTrn		=	1;
		int      trnRecords		=	1;
		boolean isDocNoAutoGenerated	=	false;
		//int failedRecordIndex = -1; Commented for Unused variable IN063878
		
		hmReturn.put(RESULT,FALSE);
		ArrayList	alDtlData1			=	(ArrayList)	hmData.get("InsertDTLData");
		System.out.println("alDtlData1" +alDtlData1);
		alTempData		=	(ArrayList) hmData.get("InsertHDRData");
		ArrayList alDelData     =    (ArrayList)	hmData.get ("DeleteDTLData");
		 //Added by sakti against ML-BRU-SCF-1091.1 to restrict adding items based on transaction per record


		try {
			connection = getConnection(properties);
			connection.setAutoCommit(false);
			alData =	(ArrayList)	hmData.get ("UpdateData");
			sql = (String)	hmSQL.get	("UpdateSQL");
			preparedStatement = connection.prepareStatement(sql);
			setData(preparedStatement,alData);
			iResult	 =	preparedStatement.executeUpdate();
			if(preparedStatement!=null)
					preparedStatement.close();
			if(iResult!=0){
				hmReturn.put(RESULT,TRUE);
				hmReturn.put(MSGID,RECORD_MODIFIED);
			}
			alData = null;
			sql = null;
			if (hmData.containsKey("DeleteDTLData") && hmSQL.containsKey("DeleteDTLSQL")) {
				alData = (ArrayList)	hmData.get ("DeleteDTLData");
				sql = (String)	hmSQL.get	("DeleteDTLSQL");
				if (alData.size() >0) {
					preparedStatement = connection.prepareStatement(sql);
					for (int index = 0; index < alData.size(); index++) {
						alRecord = (java.util.ArrayList) alData.get(index);
						setData(preparedStatement, alRecord);
						preparedStatement.addBatch();
					}
					iaResult = preparedStatement.executeBatch();
					if(preparedStatement!=null)
					preparedStatement.close();
					for (int i=0;i<iaResult.length ;i++){
						if((iaResult[i] != -2) && (iaResult[i]<0)){
							isUpdateSuccessful = false;
							break;
						}	
					}
					if(!isUpdateSuccessful){
						connection.rollback();
						throw new EJBException("Update failed while inserting detail record");
					}
				}
			}
			alData = null;
			sql = null;
			if (hmData.containsKey("UpdateDTLData") && hmSQL.containsKey("UpdateDTLSQL")) {
				alData = (ArrayList)	hmData.get ("UpdateDTLData");
				sql = (String)	hmSQL.get	("UpdateDTLSQL");
				if (alData.size() >0) {
					preparedStatement = connection.prepareStatement(sql);
					for (int index = 0; index < alData.size(); index++) {
						alRecord = (java.util.ArrayList) alData.get(index);
						setData(preparedStatement, alRecord);
						preparedStatement.addBatch();
					}
					iaResult = preparedStatement.executeBatch();
					if(preparedStatement!=null)
					preparedStatement.close();
					for (int i=0;i<iaResult.length ;i++) {
						if((iaResult[i] != -2) && (iaResult[i]<0)){
							isUpdateSuccessful = false;
							break;
						}	
					}
					if(!isUpdateSuccessful){
						connection.rollback();
						throw new EJBException("Update failed while inserting detail record");
					}	
				}
			}

			//Added by sakti against ML-BRU-SCF-1091.1 to restrict adding items based on transaction per record
			String 	sql_st_records_per_trn_select		=	(String)hmSQL.get ("sql_st_records_per_trn_select");
			HashMap records	=	fetchRecord(connection, sql_st_records_per_trn_select,trn_type);
			int records_per_trn = 0;
			if((String)records.get("RECORDS_PER_TRN")!=null){
				records_per_trn = Integer.parseInt((String)records.get("RECORDS_PER_TRN"));
			}else{
				records_per_trn = alDtlData1.size();
			}
			//MO-CRF-20176 
			String		onStore =""; 
			onStore = (String)hmData.get("REQUEST_ON_STORE");//MO-CRF-20176 
			String 	sql_st_store_records_per_trn_select		=	(String)hmSQL.get ("sql_st_store_records_per_trn_select");
			HashMap records1	=	fetchRecord(connection, sql_st_store_records_per_trn_select,onStore);
			int records_per_trn_iss = 0;
			if((String)records1.get("RECORDS_PER_TRN_ISS")!=null){
				records_per_trn_iss = Integer.parseInt((String)records1.get("RECORDS_PER_TRN_ISS"));
			}  
			System.out.println("records_per_trn: "+records_per_trn);
			System.out.println("records_per_trn_iss:"+records_per_trn_iss);
			if(records_per_trn_iss != 0){
				records_per_trn = records_per_trn_iss;
			}
			 int new_records_size = alDtlData1.size()-alDelData.size();
			 if(alDelData.size() < records_per_trn) {
				 int new_records_size1 = records_per_trn-alDelData.size();
				 new_records_size = new_records_size-new_records_size1;
			 }
			 //Added by sakti against ML-BRU-SCF-1091.1 to restrict adding items based on transaction per record added ends

			if (hmData.containsKey("InsertDTLData") && hmSQL.containsKey("InsertDTLSQL")) {
				alData = (ArrayList)	hmData.get ("InsertDTLData");
				sql = (String)	hmSQL.get	("InsertDTLSQL");
				preparedStatement = connection.prepareStatement(sql);

				if( records_per_trn > alData.size()) {
					trnRecords = alData.size();
				}else{
					trnRecords = records_per_trn;
				}

				//for (int index = 0; index < alData.size(); index++) {
					for (int index = 0; index < trnRecords; index++) {
					alRecord = (java.util.ArrayList) alData.get(index);
					setData(preparedStatement, alRecord);
					preparedStatement.addBatch();
				}
				iaResult = preparedStatement.executeBatch();
				if(preparedStatement!=null)
					preparedStatement.close();
				//preparedStatement.clearParameters();
				for (int i=0;i<iaResult.length ;i++){
					if((iaResult[i] != -2) && (iaResult[i]<0)){
						isUpdateSuccessful = false;
						break;
					}	
				}
			}
			//Added by sakti against ML-BRU-SCF-1091.1 to restrict adding items based on transaction per record added 

	if(alDtlData1.size() > records_per_trn) {
			 			
			if(item_class_based.equals("Y")){
				sizeOfTrn = alItemClassCount.size();
			}else{
				if(records_per_trn>new_records_size){
					sizeOfTrn = 1;
				}else if((new_records_size%records_per_trn)==0){
					sizeOfTrn =new_records_size/records_per_trn;
				}else{
					sizeOfTrn = (new_records_size/records_per_trn)+1;
				}
			}
			
			
		 
			sql_sy_acc_entity_doc_type_select		=	(String)hmSQL.get ("sql_sy_acc_entity_doc_type_select");
			sql_sy_acc_entity_doc_type_select_flag	=	(String)hmSQL.get ("sql_sy_acc_entity_doc_type_select_flag");
			
						for(int j=0,k=records_per_trn;j<sizeOfTrn;j++){
							if(item_class_based.equals("Y")){
								alModifyData = (ArrayList)alTempData.get(j);
							}else{
								alModifyData = alTempData;
							}
							HashMap hmRecord	=	fetchRecord(connection, sql_sy_acc_entity_doc_type_select_flag, (String)alModifyData.get(1));
							
							isDocNoAutoGenerated=	checkForNull((String)hmRecord.get("DOC_NUM_GEN_FLAG"),"Y").equals("Y");
							ArrayList allanguageData			=	(ArrayList)	hmData.get("LANGUAGE_DATA");
							String locale=(String)allanguageData.get(0);
							
							if (isDocNoAutoGenerated) {
								Connection connection111 = ConnectionManager.getConnection();	
								connection111.setAutoCommit(false);
								doc_no_temp = 	(String)fetchRecord(connection111, sql_sy_acc_entity_doc_type_select, (String)alModifyData.get(1)).get("NEXT_DOC_NO");
								alModifyData.set(2,doc_no_temp);
								doc_no.add(doc_no_temp);
								
								//Update the sy_acc_entity_doc_type with the next number for peformance 9:27 AM 3/27/2010
															
								String s  = "";
								String s1 = "";
								sql = (String)	hmSQL.get	("sql_sy_UpdateSQL");
								ArrayList newAlData = (ArrayList)	hmData.get ("Sy_UpdateData");
								preparedStatement = connection111.prepareStatement(sql);
								setData(preparedStatement,newAlData);
								iResult = preparedStatement.executeUpdate();
								connection111.commit();
								
								if(doc_no.size()>1){
									java.util.Locale loc = new java.util.Locale(locale);
									java.util.ResourceBundle common_labels = java.util.ResourceBundle.getBundle( "eCommon.resources.Labels",loc);
									s = getSTMessage(locale, "DOC_NOS_GEN_FROM", "ST") ;
								
									s1=s+"  "+doc_no.get(0)+" "+common_labels.getString("Common.to.label")+" "+doc_no.get(doc_no.size()-1);
								}else{
									s = getSTMessage(locale, "DOC_NO", "ST") ;
									s1=s+":  "+doc_no.get(0);
								}
								hmReturn.put("flag",s1);
								if(preparedStatement!=null)
										preparedStatement.close();
										
								
								if(iResult<=0){
									connection111.rollback();
									connection111.close();
									throw new SQLException("Update of Document No failed");
								}else{
									connection111.close();
								}					
							}

							// Insert Header Value
							
						sql = (String) hmSQL.get	("InsertHDRSQL");
						preparedStatement = connection.prepareStatement(sql);
							setData(preparedStatement,alModifyData);
							iResult = preparedStatement.executeUpdate();
							if(preparedStatement!=null)
									preparedStatement.close();
							if(iResult != 0) {
								hmReturn.put(RESULT,TRUE);
								hmReturn.put(MSGID,RECORD_INSERTED);
							}
							else {
								connection.rollback();
								throw new EJBException("Insert failed in header");
							}
							
					
								
			alData = null;
			sql = null;
		
			if (hmData.containsKey("InsertDTLData") && hmSQL.containsKey("InsertDTLSQL")) {
				
				      // doc_no.size();
				
				alData = (ArrayList)	hmData.get ("InsertDTLData");
				sql = (String)	hmSQL.get	("InsertDTLSQL");
				preparedStatement = connection.prepareStatement(sql);
				if(item_class_based.equals("Y")){
					trnRecords = k + alItemClassCount.get(j);
				}else{
					if(records_per_trn>alData.size()){
						trnRecords = alData.size();
					}else if((k+records_per_trn)>=alData.size()){
						trnRecords = alData.size();
					}else{
							trnRecords = k+records_per_trn;
					}
				}
				
				for (int index = k; index < trnRecords; index++) {
				 
					alRecord = (java.util.ArrayList) alData.get(index);
				    alRecord.set(2,doc_no_temp);
				  	setData(preparedStatement, alRecord);
					preparedStatement.addBatch();
				}
				iaResult = preparedStatement.executeBatch();
				if(preparedStatement!=null)
					preparedStatement.close();
				//preparedStatement.clearParameters();
				for (int i=0;i<iaResult.length ;i++){
					if((iaResult[i] != -2) && (iaResult[i]<0)){
						isUpdateSuccessful = false;
						break;
					}	
				}
			}
			
			if(item_class_based.equals("Y")){
				k = k + alItemClassCount.get(j);
			}else{
				k=k+records_per_trn;
			}
		}	
	}
//Added by sakti against ML-BRU-SCF-1091.1 to restrict adding items based on transaction per record added ends

			alData = null;
			sql = null;
			// Update Item Store
			if (hmSQL.containsKey("UpdateITMSQL") && hmData.containsKey("UpdateITMData")) {
				sql = null;
				alData = null;
				preparedStatement = null;
				alData = (ArrayList)	hmData.get ("UpdateITMData");
				sql = (String)	hmSQL.get	("UpdateITMSQL");
				preparedStatement = connection.prepareStatement(sql);
				for (int index = 0; index < alData.size(); index++) {
					alRecord = (java.util.ArrayList) alData.get(index);
					setData(preparedStatement, alRecord);
					preparedStatement.addBatch();
				}
				iaResult = preparedStatement.executeBatch();
				//preparedStatement.clearParameters();
				for (int i=0;i<iaResult.length ;i++){
					if((iaResult[i] != -2) && (iaResult[i]<0)){
						isUpdateSuccessful = false;
						break;
					}	
				}
				if(!isUpdateSuccessful){
					connection.rollback();
					throw new EJBException("Update failed while inserting detail record");
				}
			}
			if(isUpdateSuccessful){
				connection.commit();
				hmReturn.put(RESULT,TRUE);
				hmReturn.put(MSGID,RECORD_MODIFIED);
			}
					closeConnection(connection,properties);	
}
		catch(Exception exception) {
			try {
				connection.rollback();
				hmReturn.put(RESULT,FALSE);
				hmReturn.put(MSGID,exception.toString());
				hmReturn.put(MESSAGE,exception.toString());
				exception.printStackTrace();
			}
			catch (Exception subexception) {
				subexception.printStackTrace();
			}
        }
		finally{
 			try{
				if(preparedStatement!=null)
					preparedStatement.close();
				closeConnection(connection,(Properties)hmData.get(properties));	
			}
			catch (Exception subexception){
				subexception.printStackTrace();
			}
		}
		return hmReturn;
	}

	/**
	* @ejb.interface-method
	*	 view-type="both"
	*/

	public HashMap delete(HashMap hmData, HashMap hmSQL)	{
		Connection connection = null;
		HashMap hmReturn = new HashMap();
		PreparedStatement preparedStatement	=	null;
		String sql = "";
		Properties properties = null;
		ArrayList alData =	new ArrayList();
//		ArrayList alRecords =	new ArrayList();
		ArrayList alRecord =	new ArrayList();
		int iaResult[] = null;
		boolean isUpdateSuccessful = true;
		int iResult = 0;
		properties =	(Properties) hmData.get("properties");
		hmReturn.put(RESULT,FALSE);
		hmReturn.put(MESSAGE,"No record found to be deleted..");
		try {
			connection = getConnection(properties);
			connection.setAutoCommit(false);
//
			alData = null;
			sql = null;
			// Update Item Store
			if (hmSQL.containsKey("UpdateITMSQL") && hmData.containsKey("UpdateITMData")) {
				alData = (ArrayList)	hmData.get ("UpdateITMData");
				sql = (String)	hmSQL.get	("UpdateITMSQL");
				preparedStatement = connection.prepareStatement(sql);
				for (int index = 0; index < alData.size(); index++) {
					alRecord = (java.util.ArrayList) alData.get(index);
					setData(preparedStatement, alRecord);
					preparedStatement.addBatch();
				}
				iaResult = preparedStatement.executeBatch();
				if(preparedStatement!=null)
					preparedStatement.close();
				//preparedStatement.clearParameters();
				for (int i=0;i<iaResult.length ;i++){
					if((iaResult[i] != -2) && (iaResult[i]<0)){
						isUpdateSuccessful = false;
						break;
					}	
				}
				if(!isUpdateSuccessful){
					connection.rollback();
					throw new EJBException("Update failed while inserting detail record");
				}
			}
			if(isUpdateSuccessful){
				connection.commit();
				hmReturn.put(RESULT,TRUE);
				hmReturn.put(MSGID,RECORD_MODIFIED);
			}
///
			//Delete Details
			alData = (ArrayList)	hmData.get("DeleteDTLData");
			sql = (String)	hmSQL.get	("DeleteDTLSQL");
			preparedStatement = connection.prepareStatement(sql);
			setData(preparedStatement,alData);
			iResult		=	preparedStatement.executeUpdate();
			if(iResult<=0) {
				connection.rollback();
				throw new Exception("Delete failed in header !");
			}
			//Delete Header
			alData = (ArrayList)	hmData.get("DeleteHDRData");
			sql = (String)	hmSQL.get	("DeleteHDRSQL");
			preparedStatement = connection.prepareStatement(sql);
			setData(preparedStatement,alData);
			iResult		=	preparedStatement.executeUpdate();
			if(preparedStatement!=null)
					preparedStatement.close();
			if(iResult<=0) {
				connection.rollback();
				throw new Exception("Delete failed in header !");
			}
			connection.commit();
			hmReturn.put(RESULT,TRUE);
			hmReturn.put(MSGID,RECORD_DELETED);
if (connection!=null) {
					closeConnection(connection,properties);	
				}		
		
		
		}
		catch(Exception exception) {
			try {
				connection.rollback();
				hmReturn.put(RESULT,FALSE);
				hmReturn.put(MESSAGE,exception.toString());
				exception.printStackTrace();
			}
			catch (Exception subexception) {
					subexception.printStackTrace();
			}
        }
		finally{
			try{
				if(preparedStatement!=null) {
					preparedStatement.close();
				}
				closeConnection(connection,(Properties)hmData.get(properties));	
			}
			catch (Exception exception){
				exception.printStackTrace();
			}
		}
		return hmReturn;
	}

	/**
	* @ejb.interface-method
	*	 view-type="both"
	*/

	public HashMap insertOT(HashMap hmData, HashMap hmSQL)	{
		HashMap hmReturn			= new HashMap();
		HashMap hashmapHDrUpdData	= new HashMap();
		HashMap hashmapHDrUpdDataQ	= new HashMap();
		HashMap hmDtlData			= new HashMap();
		//PreparedStatement preparedStatement	=	null;
		String sql					=	"";
		ArrayList alData			= null;
		ArrayList alHdrData			= null;
		ArrayList alTempData		= null;
		ArrayList alRecord			= null;
		Properties properties		= null;
		String doc_no				= "";
		String doc_no_temp			= "";
		//String   trn_type			= "ISS";

		//boolean isUpdateSuccessful	= true;
		boolean isDocNoAutoGenerated= false;
		//int iResult = 0;
		//int failedRecordIndex		= -1;
		//int[] iaResult				= null;
		hmReturn.put(RESULT,FALSE);
		Connection connection		=  null;
		try {
			properties =	(Properties) hmData.get("properties");
			connection = (Connection)hmData.get("CONNECTION");
			connection.setAutoCommit(false);


			//String 	sql_st_records_per_trn_select		=	(String)hmSQL.get ("sql_st_records_per_trn_select");
			//HashMap records	=	fetchRecord(connection, sql_st_records_per_trn_select,trn_type);

			sql_sy_acc_entity_doc_type_select		=	(String)hmSQL.get ("sql_sy_acc_entity_doc_type_select");
			sql_sy_acc_entity_doc_type_select_flag	=	(String)hmSQL.get ("sql_sy_acc_entity_doc_type_select_flag");

			// Insert Header Value
			alHdrData =	(ArrayList) hmData.get("InsertHDRData");
			hmDtlData =	(HashMap) hmData.get("InsertDTLData");
			for(int i=0;i<alHdrData.size();i++){
				alData = (ArrayList)alHdrData.get(i);
				HashMap hmRecord	=	fetchRecord(connection, sql_sy_acc_entity_doc_type_select_flag, (String)alData.get(1));
				isDocNoAutoGenerated=	checkForNull((String)hmRecord.get("DOC_NUM_GEN_FLAG"),"Y").equals("Y");
				if (isDocNoAutoGenerated) {
					doc_no_temp = 	(String)fetchRecord(connection, sql_sy_acc_entity_doc_type_select, (String)alData.get(1)).get("NEXT_DOC_NO");
				}
				alData.set(2,doc_no_temp);
				doc_no = doc_no+(String)alData.get(2)+"~";
				alTempData = new ArrayList();
				alTempData.add(alData);
				hashmapHDrUpdData.put("DATA",alTempData);
				hashmapHDrUpdDataQ.put(BATCH_SQL,(String)hmSQL.get("InsertHDRSQL"));
				hmReturn =  operateBatch(connection, hashmapHDrUpdData, hashmapHDrUpdDataQ);
				throwExceptionWhenFailed(hmReturn);
				// Insert Detail Value
				alData = (ArrayList)hmDtlData.get(alData.get(8));
				
				for (int index=0;index<alData.size() ;index++ ) {
					alRecord = (ArrayList) alData.get(index);
					alRecord.set(2,doc_no_temp);
					alData.set(index,alRecord);
				}
				hashmapHDrUpdData.put("DATA",alData);
				hashmapHDrUpdDataQ.put(BATCH_SQL,(String)hmSQL.get("InsertDTLSQL"));
				hmReturn =  operateBatch(connection, hashmapHDrUpdData, hashmapHDrUpdDataQ);
				throwExceptionWhenFailed(hmReturn);

				sql = null;
				alData = null;
				//preparedStatement = null;
				//Update the document no
				//ArrayList allanguageData			=	(ArrayList)	hmData.get("LANGUAGE_DATA");
				//String locale=(String)allanguageData.get(0);
				if (isDocNoAutoGenerated) {
					alData = (ArrayList)	hmData.get ("UpdateData");
					alTempData = new ArrayList();
					alTempData.add(alData);
					hashmapHDrUpdData.put("DATA",alTempData);
					hashmapHDrUpdDataQ.put(BATCH_SQL,(String)hmSQL.get("UpdateSQL"));
					hmReturn =  operateBatch(connection, hashmapHDrUpdData, hashmapHDrUpdDataQ);
					throwExceptionWhenFailed(hmReturn);
				}
			}
				alData = (ArrayList)hmData.get("UpdateITMData");
				hashmapHDrUpdData.put("DATA",alData);
				hashmapHDrUpdDataQ.put(BATCH_SQL,(String)hmSQL.get("UpdateITMSQL"));
				hmReturn =  operateBatch(connection, hashmapHDrUpdData, hashmapHDrUpdDataQ);
				throwExceptionWhenFailed(hmReturn);

				// After successful insertion and updation 

				
				//connection.commit();
				//connection.rollback();
				hmReturn.put(RESULT,TRUE);
				hmReturn.put(MSGID,RECORD_INSERTED);
		}
		catch(SQLException sqlException) {
			try {
				connection.rollback();
				hmReturn.put(RESULT,FALSE);
				if(sqlException.getErrorCode()==1) {
					hmReturn.put(MESSAGE,CODE_ALREADY_EXISTS);
				}
				else {
					hmReturn.put(MESSAGE,sqlException.toString());
				}
				sqlException.printStackTrace();
			}
			catch (Exception exception) {
				exception.printStackTrace(); 
			}
        }
		catch(Exception exception) {
			try {
				connection.rollback();
				hmReturn.put(RESULT,FALSE);
				hmReturn.put(MESSAGE,exception.toString());
				exception.printStackTrace();
			}
			catch (Exception subexception) {
				subexception.printStackTrace(); 
			}
        }
		hmReturn.put("req_doc_no",doc_no);
		return hmReturn;
	}





//	protected final String UPDATE_DATA = "UpdateData";
//	protected final String UPDATE_SQL = "UpdateSQL";
	protected final String MESSAGE = "message";
	protected final String RESULT = "result";
	protected final Boolean TRUE = new Boolean(true);
	protected final Boolean FALSE =	new Boolean(false);
	private final String CODE_ALREADY_EXISTS = "CODE_ALREADY_EXISTS";
    private final String RECORD_INSERTED = "RECORD_INSERTED";
    private final String RECORD_MODIFIED = "RECORD_MODIFIED";
    private final String RECORD_DELETED  =	"RECORD_DELETED";
}
