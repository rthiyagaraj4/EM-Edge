/*******************************************************************************
 * Copyright 1999-2015, Computer Sciences Corporation. All rights reserved.
 *  
 * Warning: This computer program is protected by copyright law and international treaties.
 * Unauthorized reproduction or distribution of this program, or any portion of it, 
 * may result in severe civil and criminal penalties, and will be prosecuted to 
 * the maximum extent possible under the law.
 ******************************************************************************/
package eST.SplitBatch;

//import java.rmi.RemoteException;
import eST.Common.StEJBSessionAdapter;
import java.sql.Connection;
import java.util.ArrayList;
import java.sql.CallableStatement;
import java.sql.Types;
import java.util.Properties;
import java.util.HashMap;

/**
*
* @ejb.bean
*	name="SplitBatch"
*	type="Stateless"
*	transaction-type="Bean"
*	view-type="both"
*	jndi-name="SplitBatch"
*	local-jndi-name="SplitBatch"
*	impl-class-name="eST.SplitBatch.SplitBatchManager"
*	
*
* @ejb.interface
*	extends="javax.ejb.EJBObject"
*	local-extends="javax.ejb.EJBLocalObject" 
*	local-class="eST.SplitBatch.SplitBatchLocal"
*	remote-class="eST.SplitBatch.SplitBatchRemote"
*	generate= "local,remote"
*
* @ejb.home
*	extends="javax.ejb.EJBHome" 
*	local-extends="javax.ejb.EJBLocalHome"
*	local-class="eST.SplitBatch.SplitBatchLocalHome"
*	remote-class="eST.SplitBatch.SplitBatchHome"
*	generate= "local,remote"
*
*
*/


public class SplitBatchManager extends StEJBSessionAdapter {

//	HashMap hmData;
//	HashMap hmSQL;
	HashMap	hmReturn;

	//Properties	properties	=	null;

	/* Variables which are needed to call the routines to update the online-store and
	other tables.
	*/

/*	String finalized_yn="";

	String item_code					= "";
	String store_code					= "";
	String trn_type						= "";
	String trn_qty						= "";
	String trn_cost						= "";
	String trn_value					= "";

	String trade_id						= "";
	String bin_location_code			= "";
	String expiry_date_or_receipt_date	= "";
	String suspended_batch_allowed_yn	= "";
	String batch_id						= "";

	String		stSQL		=	null;*/


	/** Dummy method
	*/
	
	/**
	* @ejb.interface-method
	*	 view-type="both"
	*/

	public HashMap modify(HashMap hmDataValues, HashMap hmSQLValues) {//throws RemoteException{
		return getMessageHashMap(false);
	}

	/** Dummy method
	*/

	/**
	* @ejb.interface-method
	*	 view-type="both"
	*/

	public HashMap delete( HashMap hmDataValues, HashMap hmSQLValues) {//throws RemoteException {
		return getMessageHashMap(false);
	}

	/**
	* Method, which is responsible for inserting the data in to the related tables
	* for the adjustStock transaction. This method will in turn call the other methods
	* to do the corresponding updates.
	* @param hmDataValues, the data to be inserted
	* @param hmSQLValues, the queries used for the corresponding updates
	* @return HashMap, the result and the messages
	*/
	
	/**
	* @ejb.interface-method
	*	 view-type="both"
	*/

	public HashMap insert(HashMap hashmap, HashMap hmSQLValues) {

        System.out.println("hashmap..."+hashmap);
        System.out.println("hmSQLValues..."+hmSQLValues);
		
		Connection connection = null;
        int      sizeOfTrn		=	1;
		//boolean isDocNoAutoGenerated	=	false;
		int      trnRecords		=	1;
        HashMap hashmapHDrdata = new HashMap();
        HashMap hashmapHDrquery = new HashMap();
        HashMap hashmapResult = new HashMap();
        HashMap hashmapDtldata = new HashMap();
        HashMap hashmapDtlquery = new HashMap();
		 HashMap hashmapDtlExpdata = new HashMap();
        HashMap hashmapDtlExpquery = new HashMap();
        HashMap hashmapSalePrice = new HashMap();
		HashMap itemClass =new HashMap();
		ArrayList alItemRow1 = new ArrayList();
		ArrayList hmHeader;
		ArrayList doc_no = new ArrayList();

        ArrayList arraylist = new ArrayList();
        ArrayList arrayBatchDtl = new ArrayList();
		ArrayList item_code_list = new ArrayList();

		CallableStatement callableStatement = null;

        Properties properties = null;
     //   Object obj = null;

        hashmapResult.put("result", FALSE);
		String batch_string[] = new String[2] ;
        try
        {
            properties = (Properties)hashmap.get("properties");
            connection = getConnection(properties);
            connection.setAutoCommit(false);
			               
             HashMap   itemtoItemClass =(HashMap)hashmap.get("itemtoItemClass");			
			HashMap item_class_based_hm = fetchRecord(connection,"SELECT ITEM_CLASS_WISE_DOCUMENTS_YN ITEM_CLASS_BASED,ITEM_CLASS_BASED_YN,ITEM_CLASS_BASED_YN FROM ST_TRN_TYPE WHERE TRN_TYPE = ?","SPB");
             String item_class_based = checkForNull((String)item_class_based_hm.get("ITEM_CLASS_BASED"),"N");
            
			 String item_class_based_yn = checkForNull((String)item_class_based_hm.get("ITEM_CLASS_BASED_YN"),"N");

			/* It is used to catch the items according to the Item Classes Ramana C
			
			Logic Written is Critical Here the itemtoItemClass plays a critical role in pursuing the further 
			Transactions

			itemtoItemClass --- It contains the Item Class as the Key and associated Items it is a Map

			So soon after the Doc No is Created then The Item Class will be removed 


			Also alItemRow1 contains set of elements falling under a specific Item Class 

			*/
			String 	sql_st_records_per_trn_select		=	"SELECT RECORDS_PER_TRN FROM ST_TRN_TYPE WHERE TRN_TYPE=?";
			HashMap records	=	fetchRecord(connection, sql_st_records_per_trn_select,"SPB");
			
			ArrayList arraylistDtlData = (ArrayList)hashmap.get("DtlInsertData");
			ArrayList arraylistHdrData = (ArrayList)hashmap.get("HdrInsertData");
            ArrayList arraylistDtlExpData = (ArrayList)hashmap.get("ExpInsertData");

			String HdrQuery = (String)hmSQLValues.get("HdrInsertSQL");
			 int records_per_trn = 0;

			int no_of_item_classes =  itemtoItemClass.size();
			 if((String)records.get("RECORDS_PER_TRN")!=null)
				records_per_trn = Integer.parseInt((String)records.get("RECORDS_PER_TRN"));
			else
				records_per_trn = arraylistDtlData.size();
						
			if(item_class_based.equals("Y")){
				//if(records_per_trn>arraylistDtlData.size())
				sizeOfTrn = no_of_item_classes;
			/*	else
				sizeOfTrn = arraylistDtlData.size();*/
			}else {
			if(records_per_trn>arraylistDtlData.size())
				sizeOfTrn = 1;
			
			else if((arraylistDtlData.size()%records_per_trn)==0)
				sizeOfTrn = arraylistDtlData.size()/records_per_trn;
			else
				sizeOfTrn = (arraylistDtlData.size()/records_per_trn)+1;
			}
           			 
             for(int j=0,k=0;j<sizeOfTrn;j++)
			{
           
          
			 alItemRow1 = new ArrayList();
			 ArrayList alItemRow1_temp = new ArrayList();
             for(int d=0;j<arraylistDtlData.size();d++)
			{
			 ArrayList alItemRow =   (ArrayList)arraylistDtlData.get(d);
			
						
			itemClass = fetchRecord(connection,"SELECT  ITEM_CLASS_CODE ITEM_CLASS_CODE FROM MM_ITEM WHERE item_code =?",(String)alItemRow.get(5));
			if(itemtoItemClass.containsKey(itemClass.get("ITEM_CLASS_CODE")))
				{	
			alItemRow1_temp     =(ArrayList)itemtoItemClass.get(itemClass.get("ITEM_CLASS_CODE"));
			if(alItemRow1_temp.size()>records_per_trn)
					{
					for(int t=0;t<records_per_trn;t++)
						{
					alItemRow1.add(alItemRow1_temp.get(t));
						}
					alItemRow1_temp.subList(0,records_per_trn).clear();
			
				}else if(alItemRow1_temp.size()==records_per_trn){
      			for(int y=0;y<alItemRow1_temp.size();y++)
						{
                  alItemRow1.add(alItemRow1_temp.get(y));
						}
				itemtoItemClass.remove(itemClass.get("ITEM_CLASS_CODE"));
				}else if(alItemRow1_temp.size()<records_per_trn){
				for(int u=0;u<alItemRow1_temp.size();u++)
						{
                  alItemRow1.add(alItemRow1_temp.get(u));
						}
				   itemtoItemClass.remove(itemClass.get("ITEM_CLASS_CODE"));
				   }
				break;
				}else
               	continue;
			}
	

			ArrayList arraylistHdrData_temp = (ArrayList) arraylistHdrData.get(0);
              
			  hmHeader = new ArrayList();
              hmHeader.add((String)arraylistHdrData_temp.get(0));
              hmHeader.add((String)arraylistHdrData_temp.get(1));
              if(((Boolean)hashmap.get("isDocNoAutoGenYN")).booleanValue()){
				hmHeader.add((String)fetchRecord(connection, "SELECT next_doc_no, doc_print_flag FROM sy_acc_entity_doc_type WHERE doc_type_code = ?", (String)arraylistHdrData_temp.get(1)).get("NEXT_DOC_NO"));
			}else
             hmHeader.add((String)arraylistHdrData_temp.get(2));
              hmHeader.add((String)arraylistHdrData_temp.get(3));
              hmHeader.add((String)arraylistHdrData_temp.get(4));
              hmHeader.add((String)arraylistHdrData_temp.get(5));
              hmHeader.add((String)arraylistHdrData_temp.get(6));
              hmHeader.add((String)arraylistHdrData_temp.get(7));
              hmHeader.add((String)arraylistHdrData_temp.get(8));
              hmHeader.add((String)arraylistHdrData_temp.get(9));
              hmHeader.add((String)arraylistHdrData_temp.get(10));
              hmHeader.add((String)arraylistHdrData_temp.get(11));
              if(item_class_based.equals("Y") ||  item_class_based_yn.equals("Y"))
            hmHeader.add((String)itemClass.get("ITEM_CLASS_CODE"));
			else
			hmHeader.add("");
			 
			  doc_no.add((String)hmHeader.get(2));
              
			 hashmapHDrdata.put("DATA",hmHeader);
			hashmapHDrquery.put(INSERT_SQL,HdrQuery);
			hashmapResult =  insert(connection, hashmapHDrdata, hashmapHDrquery);
			throwExceptionWhenFailed(hashmapResult);

			
			if(item_class_based.equals("Y")){
				trnRecords =  k+alItemRow1.size();
			}else{
				if(records_per_trn>arraylistDtlData.size()){
					trnRecords = arraylistDtlData.size();
				}else if((k+records_per_trn)>=arraylistDtlData.size()){
					trnRecords = arraylistDtlData.size();
				}else{
					trnRecords = k+records_per_trn;
				}
			}
            item_code_list = new ArrayList();
									
			for (int i=k;i<trnRecords ;i++ ) {	
			ArrayList hmDtl = new ArrayList();
            ArrayList hmDtlTemp = (ArrayList)arraylistDtlData.get(i);
			
			
			
			hmDtl.add((String)hmDtlTemp.get(0));
			hmDtl.add((String)hmDtlTemp.get(1));
			hmDtl.add((String)hmHeader.get(2));
			hmDtl.add((String)hmDtlTemp.get(3));
			hmDtl.add((String)hmDtlTemp.get(4));
			hmDtl.add((String)hmDtlTemp.get(5));
			hmDtl.add((String)hmDtlTemp.get(6));
			hmDtl.add((String)hmDtlTemp.get(7));
			hmDtl.add((String)hmDtlTemp.get(8));
			hmDtl.add((String)hmDtlTemp.get(9));
			hmDtl.add((String)hmDtlTemp.get(10));
			hmDtl.add((String)hmDtlTemp.get(11));
			hmDtl.add((String)hmDtlTemp.get(12));
			hmDtl.add((String)hmDtlTemp.get(13));
			hmDtl.add((String)hmDtlTemp.get(14));
			hmDtl.add((String)hmDtlTemp.get(15));
			hmDtl.add((String)hmDtlTemp.get(16));
			hmDtl.add((String)hmDtlTemp.get(17));
			hmDtl.add((String)hmDtlTemp.get(18)); //supp_code
			item_code_list.add((String)hmDtlTemp.get(5));
			
			
			String DtlQuery = (String)hmSQLValues.get("DtlInsertSQL");
			hashmapDtldata.put("DATA",hmDtl);
			hashmapDtlquery.put(INSERT_SQL,DtlQuery);
			
			hashmapResult =  insert(connection, hashmapDtldata, hashmapDtlquery);
			throwExceptionWhenFailed(hashmapResult);
			}
			// Added by Shaiju for split batch sale price
			arrayBatchDtl=(ArrayList)hashmap.get("BatchUpdateDtlRows");
			if(arrayBatchDtl.size() > 0 )
				{
					for(int i = 0; i < arrayBatchDtl.size(); i++)
					{
						ArrayList arraylistDtl = new ArrayList();
						arraylistDtl = (ArrayList)arrayBatchDtl.get(i);
						hashmapSalePrice.put((String)arraylistDtl.get(0),(String)arraylistDtl.get(4)+"~"+(String)arraylistDtl.get(5));
					}
				}
				System.out.println("hashmapSalePrice...."+hashmapSalePrice);


			arrayBatchDtl =new ArrayList();
			
			for (int g=0;g<item_code_list.size() ;g++ ){

			for (int h=0;h<arraylistDtlExpData.size() ;h++ ){

           ArrayList hmExpRecord		= (ArrayList)arraylistDtlExpData.get(h);
		 
		   if(!((String)item_code_list.get(g)).equals((String)hmExpRecord.get(5))) {
					continue;
			}
			ArrayList alExpRecord	= new ArrayList();

             alExpRecord.add((String)hmExpRecord.get(0));
             alExpRecord.add((String)hmExpRecord.get(1));
             alExpRecord.add((String)hmHeader.get(2));
             alExpRecord.add((String)hmExpRecord.get(3));
             alExpRecord.add((String)hmExpRecord.get(4));
             alExpRecord.add((String)hmExpRecord.get(5));
             alExpRecord.add((String)hmExpRecord.get(6));
             alExpRecord.add((String)hmExpRecord.get(7));
             alExpRecord.add((String)hmExpRecord.get(8));
             alExpRecord.add((String)hmExpRecord.get(9));
             alExpRecord.add((String)hmExpRecord.get(10));
             alExpRecord.add((String)hmExpRecord.get(11));
             alExpRecord.add((String)hmExpRecord.get(12));
             alExpRecord.add((String)hmExpRecord.get(13));
             alExpRecord.add((String)hmExpRecord.get(14));
             alExpRecord.add((String)hmExpRecord.get(15));
             alExpRecord.add((String)hmExpRecord.get(16));
			 alExpRecord.add(checkForNull((String)hmExpRecord.get(17))); //04/05/12

			String DtlExpQuery = (String)hmSQLValues.get("ExpInsertSQL");
			hashmapDtlExpdata.put("DATA",alExpRecord);
			hashmapDtlExpquery.put(INSERT_SQL,DtlExpQuery);
			hashmapResult =  insert(connection, hashmapDtlExpdata, hashmapDtlExpquery);
			throwExceptionWhenFailed(hashmapResult);
			
			/*
			
			// Added for billing price insertions starts
			
			System.out.println("Item code...."+hmExpRecord.get(5));
			//System.out.println("Batch Id...."+hmExpRecord.get(6));
			//System.out.println("Expiry date...."+hmExpRecord.get(8));
			
			batch_string = ((String) hashmapSalePrice.get((String)hmExpRecord.get(5))).split("~");
			System.out.println("Batch Id...."+batch_string[0]);
			System.out.println("Expiry date...."+batch_string[1]);
			
			
			ArrayList alParam	=	new ArrayList();
			alParam.add((String)hmExpRecord.get(5));
			alParam.add(batch_string[0]);
			alParam.add(batch_string[1]);

			String sale_price = (String)fetchRecord(connection, "SELECT SALE_PRICE FROM ST_BATCH_CONTROL WHERE ITEM_CODE = ? AND BATCH_ID = ? AND EXPIRY_DATE_OR_RECEIPT_DATE =  to_date(?,'DD/MM/YYYY')", alParam).get("SALE_PRICE");

			System.out.println(" sale_price......"+sale_price);
			HashMap		hmArgData1	=	new HashMap();
			HashMap		hmArgSQL1	=	new HashMap();
			alParam	=	new ArrayList();
			alParam.add(sale_price);
			alParam.add((String)hmExpRecord.get(5));
			alParam.add((String)hmExpRecord.get(6));
			alParam.add((String)hmExpRecord.get(8));
			hmArgData1.put(DATA,alParam);
			hmArgSQL1.put(UPDATE_SQL,"UPDATE ST_BATCH_CONTROL set SALE_PRICE = ? WHERE ITEM_CODE = ? AND BATCH_ID = ? AND EXPIRY_DATE_OR_RECEIPT_DATE =  to_date(?,'DD/MM/YYYY')");
			hmReturn	=	update(connection, hmArgData1, hmArgSQL1);	
			
			System.out.println("hmReturn..in update part..."+hmReturn);
			
			callableStatement	= connection.prepareCall("{ CALL BLCOMMON.CREATE_MATERIAL_BATCH_PRICE(?,?,?,?,SYSDATE,?,?,?,?,?) }");
			System.out.println("hmExpRecord.get(5)..."+hmExpRecord.get(5)+"..hmExpRecord.get(9)..."+hmExpRecord.get(9)+"...hmExpRecord.get(6)...."+hmExpRecord.get(6)+"..hmExpRecord.get(11).."+hmExpRecord.get(11)+"..hmExpRecord.get(12)..."+hmExpRecord.get(12));
			callableStatement.setString(1, (String)hmExpRecord.get(5));
			callableStatement.setString(2, (String)hmExpRecord.get(9));
			callableStatement.setString(3, (String)hmExpRecord.get(6));
			callableStatement.setString(4, sale_price);//sale price 
			callableStatement.setString(5, (String)hmExpRecord.get(11));
			callableStatement.setString(6, (String)hmExpRecord.get(12));
			callableStatement.registerOutParameter(7, Types.VARCHAR);//Error Code
			callableStatement.registerOutParameter(8, Types.VARCHAR);//sys message id
			callableStatement.registerOutParameter(9, Types.VARCHAR);//error text
			callableStatement.execute();
			if (callableStatement.getString(8)!=null || (callableStatement.getString(9)!=null && !callableStatement.getString(9).equals("UNABLE TO INSERT BL_ST_ITEM_BY_TRADENAMEORA-00001: unique constraint (IBAEHIS.BL_ST_ITEM_BY_TRADENAME_PK) violated") &&callableStatement.getString(7).equals("10")))
							throw new Exception (callableStatement.getString(9));


			closeStatement(callableStatement);
			*/

			// Added for billing price insertions Ends

			}
			}
			
			if(item_class_based.equals("Y")){
					k = k + alItemRow1.size();
				}else{
					k=k+records_per_trn;
				}
			if(((Boolean)hashmap.get("isDocNoAutoGenYN")).booleanValue())
				hashmapResult =generateDocNo(connection,hashmap,hmSQLValues) ;
			}
			
			insertTrnDtl(connection,(ArrayList)	hashmap.get("TrnDtlData"),(String)hmSQLValues.get("ItemTrnDtlInsert")) ;
				insertTrnDtl(connection,(ArrayList)	hashmap.get("TrnDtlExpData"),(String)hmSQLValues.get("ItemTrnDtlInsert")) ;

				arrayBatchDtl=(ArrayList)hashmap.get("BatchUpdateDtlRows");
				if(arrayBatchDtl.size() > 0 )
				{
					for(int i = 0; i < arrayBatchDtl.size(); i++)
					{
						ArrayList arraylistDtl = new ArrayList();
						arraylistDtl = (ArrayList)arrayBatchDtl.get(i);
						System.out.println("arraylistDtl....1...."+arraylistDtl);
						updateBatchOnLine(connection,hmSQLValues,commonParams(arraylistDtl));
						//updateBatchHistoryOnLine(connection,hmSQLValues,commonParams(arraylistDtl));
					}
				}
				arraylist=(ArrayList)hashmap.get("BatchUpdateDtl");
				if(arraylist.size() > 0)
				{
					for(int i = 0; i < arraylist.size(); i++)
					{
						ArrayList arraylist2 = new ArrayList();
						arraylist2 = (ArrayList)arraylist.get(i);
				System.out.println("arraylist2==460==>" +arraylist2);
				//Added for not to update Sales price of an Existing Batch Starts
				
				ArrayList alTemp	=	new ArrayList();
				HashMap hmResult = new HashMap();
				alTemp.add((String)arraylist2.get(0));
				alTemp.add((String)arraylist2.get(4));
				alTemp.add((String)arraylist2.get(5));

				hmResult		= fetchRecord(connection, "SELECT COUNT(*) COUNT FROM ST_BATCH_CONTROL WHERE ITEM_CODE = ? AND BATCH_ID = ? AND EXPIRY_DATE_OR_RECEIPT_DATE =  to_date(?,'DD/MM/YYYY')", alTemp);		
				int batch_count	= Integer.parseInt((String)(hmResult.get("COUNT")));
				
				System.out.println("batch_count....2."+i+"--"+batch_count);
				updateBatchOnLine(connection,hmSQLValues,commonParams(arraylist2));
				//updateBatchHistoryOnLine(connection,hmSQLValues,commonParams(arraylist2));
			
			// Added for billing price insertions starts
			
			String sale_price = "";

		if (batch_count==0){

			batch_string = ((String) hashmapSalePrice.get((String)arraylist2.get(0))).split("~");
			System.out.println("Batch Id...."+batch_string[0]);
			System.out.println("Expiry date...."+batch_string[1]);
						
			ArrayList alParam	=	new ArrayList();
			alParam.add((String)arraylist2.get(0));
			alParam.add(batch_string[0]);
			alParam.add(batch_string[1]);

			 sale_price = (String)fetchRecord(connection, "SELECT SALE_PRICE FROM ST_BATCH_CONTROL WHERE ITEM_CODE = ? AND BATCH_ID = ? AND EXPIRY_DATE_OR_RECEIPT_DATE =  to_date(?,'DD/MM/YYYY')", alParam).get("SALE_PRICE");


			if (sale_price == null ){
				sale_price = "";
			}

			System.out.println(" sale_price......"+sale_price);
			HashMap		hmArgData1	=	new HashMap();
			HashMap		hmArgSQL1	=	new HashMap();
			alParam	=	new ArrayList();
			alParam.add(sale_price);
			alParam.add((String)arraylist2.get(0));
			alParam.add((String)arraylist2.get(4));
			alParam.add((String)arraylist2.get(5));
			hmArgData1.put(DATA,alParam);
			hmArgSQL1.put(UPDATE_SQL,"UPDATE ST_BATCH_CONTROL set SALE_PRICE = ? WHERE ITEM_CODE = ? AND BATCH_ID = ? AND EXPIRY_DATE_OR_RECEIPT_DATE =  to_date(?,'DD/MM/YYYY')");
			hmReturn	=	update(connection, hmArgData1, hmArgSQL1);	
			
			System.out.println("hmReturn..in update part..."+hmReturn);

				if(!(sale_price.equals(""))){ // add if condition for 35322	ML-BRU-SCF-0468 by ganga
				
					//callableStatement	= connection.prepareCall("{ CALL BLCOMMON.CREATE_MATERIAL_BATCH_PRICE(?,?,?,?,SYSDATE,?,?,?,?,?) }");
					callableStatement	= connection.prepareCall("{ CALL BLCOMMON.CREATE_MATERIAL_BATCH_PRICE(?,?,?,?,SYSDATE,?,?,?,?,?,?,?) }");//Modified for AMS-SCF-0277.1
					System.out.println("arraylist2.get(0)..item."+arraylist2.get(0)+"..arraylist2.get(0)...trade.."+arraylist2.get(6)+"...arraylist2.get(4)..batch.."+arraylist2.get(4)+"..arraylist2.get(9)..user..."+arraylist2.get(9)+"..arraylist2.get(10)..WS..."+arraylist2.get(10));
					callableStatement.setString(1, (String)arraylist2.get(0));//item
					callableStatement.setString(2, (String)arraylist2.get(6));//trade
					callableStatement.setString(3, (String)arraylist2.get(4));//Batch
					callableStatement.setString(4, sale_price);//sale price 
					callableStatement.setString(5, (String)arraylist2.get(9));//user
					callableStatement.setString(6, (String)arraylist2.get(10));//WS
					callableStatement.registerOutParameter(7, Types.VARCHAR);//Error Code
					callableStatement.registerOutParameter(8, Types.VARCHAR);//sys message id
					callableStatement.registerOutParameter(9, Types.VARCHAR);//error text
					callableStatement.setString(10, "-1");//Added for AMS-SCF-0277.1 
System.err.println("login_facility_id in split batch stockfor SCF-0277.1@@@==="+(String)arraylist2.get(11));
					callableStatement.setString(11, (String)arraylist2.get(11));//Added for AMS-SCF-0277.1 
					callableStatement.execute();
					if (callableStatement.getString(8)!=null || (callableStatement.getString(9)!=null && !callableStatement.getString(9).equals("UNABLE TO INSERT BL_ST_ITEM_BY_TRADENAMEORA-00001: unique constraint (IBAEHIS.BL_ST_ITEM_BY_TRADENAME_PK) violated") &&callableStatement.getString(7).equals("10")))
									throw new Exception (callableStatement.getString(9));


					closeStatement(callableStatement);
				}

			}
			else{

			System.out.println("Item code...."+arraylist2.get(0));
			System.out.println("Batch Id...."+arraylist2.get(4));
			System.out.println("Expiry date...."+arraylist2.get(5));
			
			
			ArrayList alParam	=	new ArrayList();
			alParam.add((String)arraylist2.get(0));
			alParam.add((String)arraylist2.get(4));
			alParam.add((String)arraylist2.get(5));

			sale_price = (String)fetchRecord(connection, "SELECT SALE_PRICE FROM ST_BATCH_CONTROL WHERE ITEM_CODE = ? AND BATCH_ID = ? AND EXPIRY_DATE_OR_RECEIPT_DATE =  to_date(?,'DD/MM/YYYY')", alParam).get("SALE_PRICE");
			
			if (sale_price ==null ){
				sale_price = "";
			}

			System.out.println("down sale_price......"+sale_price);

			
				if(!(sale_price.equals(""))){ // add if condition for 35322	ML-BRU-SCF-0468 by ganga

					//callableStatement	= connection.prepareCall("{ CALL BLCOMMON.CREATE_MATERIAL_BATCH_PRICE(?,?,?,?,SYSDATE,?,?,?,?,?) }");
					callableStatement	= connection.prepareCall("{ CALL BLCOMMON.CREATE_MATERIAL_BATCH_PRICE(?,?,?,?,SYSDATE,?,?,?,?,?,?,?) }");//Modified for AMS-SCF-0277.1 
					System.out.println("arraylist2.get(0)..item."+arraylist2.get(0)+"..arraylist2.get(0)...trade.."+arraylist2.get(6)+"...arraylist2.get(4)..batch.."+arraylist2.get(4)+"..arraylist2.get(9)..user..."+arraylist2.get(9)+"..arraylist2.get(10)..WS..."+arraylist2.get(10));
					callableStatement.setString(1, (String)arraylist2.get(0));//item
					callableStatement.setString(2, (String)arraylist2.get(6));//trade
					callableStatement.setString(3, (String)arraylist2.get(4));//Batch
					callableStatement.setString(4, sale_price);//sale price 
					callableStatement.setString(5, (String)arraylist2.get(9));//user
					callableStatement.setString(6, (String)arraylist2.get(10));//WS
					callableStatement.registerOutParameter(7, Types.VARCHAR);//Error Code
					callableStatement.registerOutParameter(8, Types.VARCHAR);//sys message id
					callableStatement.registerOutParameter(9, Types.VARCHAR);//error text
					callableStatement.setString(10,"-1");//Added for AMS-SCF-0277.1 
					System.err.println("login_facility_id in split batch22 stockfor SCF-0277.1@@@==="+(String)arraylist2.get(11));
					callableStatement.setString(11, (String)arraylist2.get(11));//Added for AMS-SCF-0277.1 
					callableStatement.execute();
					if (callableStatement.getString(8)!=null || (callableStatement.getString(9)!=null && !callableStatement.getString(9).equals("UNABLE TO INSERT BL_ST_ITEM_BY_TRADENAMEORA-00001: unique constraint (IBAEHIS.BL_ST_ITEM_BY_TRADENAME_PK) violated") &&callableStatement.getString(7).equals("10")))
									throw new Exception (callableStatement.getString(9));


					closeStatement(callableStatement);
				
				}
			
			}
							// Added for billing price insertions Ends

		}
	}
	//Added for not to update Sales price of an Existing Batch Ends
				
				System.out.println("arrayBatchDtl...3..."+arrayBatchDtl);
				System.out.println("arraylist..4...."+arraylist);

				ArrayList LanguageData = (ArrayList)hashmap.get("LanguageData");

				String locale=(String)LanguageData.get(0);
				if(((Boolean)hashmap.get("isDocNoAutoGenYN")).booleanValue()){
					String s  = "";
					String s1 = "";
			
				ArrayList alParameters	=	new ArrayList();
				ArrayList hmCommon = (ArrayList)hashmap.get("CommonData");
				alParameters.add(hmCommon.get(0));
				alParameters.add(hmCommon.get(1));
				alParameters.add(hmCommon.get(2));
				alParameters.add(hmCommon.get(3));
				if(doc_no.size()>1){
						java.util.Locale loc = new java.util.Locale(locale);
						java.util.ResourceBundle common_labels = java.util.ResourceBundle.getBundle( "eCommon.resources.Labels",loc);
						s = getSTMessage(locale, "DOC_NOS_GEN_FROM", "ST") ;

						s1=s+"  "+doc_no.get(0)+" "+common_labels.getString("Common.to.label")+" "+doc_no.get(doc_no.size()-1);
					}else{
						s = getSTMessage(locale, "DOC_NO", "ST") ;
						s1=s+":  "+doc_no.get(0);
					}
				hashmapResult.put("flag",s1);
				}
            connection.commit();
        }
        catch(Exception exception)
        {
            try
            {
                connection.rollback();
                exception.printStackTrace();
            }
            catch(Exception exception1)
            {
                exception1.printStackTrace();
            }
            hashmapResult.put("result", FALSE);
            hashmapResult.put("msgid", exception.getMessage());
            hashmapResult.put("message", exception.toString());
        }
        finally
        {
            try
            {
                closeConnection(connection, properties);
            }
            catch(Exception exception3)
            {
                exception3.printStackTrace();
            }
        }
        return hashmapResult;
    }

	public HashMap generateDocNo( Connection connection,HashMap hmData,HashMap hmSQL) throws Exception {
		HashMap		hmArgData	=	new HashMap();
		HashMap		hmArgSQL	=	new HashMap();
//		ArrayList	alHdrData	=	new ArrayList();
		ArrayList	alCommonData;
		String		stSQL		=	null;

		alCommonData	=	(ArrayList)	hmData.get("CommonData");
		stSQL			=	(String)	hmSQL.get ("NextDocNoUpdateSQL");


		hmArgData.put(DATA,alCommonData);
		hmArgSQL.put(UPDATE_SQL,stSQL);

		hmReturn	=	update(connection, hmArgData, hmArgSQL);
		throwExceptionWhenFailed(hmReturn);
        
		return hmReturn;

		//hmReturn.put("flag","Doc No: "+alHdrData.get(2));
	}

	public void insertTrnDtl( Connection connection,ArrayList alCommonData,String  stSQL) throws Exception {
		HashMap		hmArgData	=	new HashMap();
		HashMap		hmArgSQL	=	new HashMap();
//		ArrayList	alHdrData	=	new ArrayList();
		HashMap	hmReturn =	new HashMap();

		hmArgData.put(DATA,alCommonData);
		hmArgSQL.put(BATCH_SQL,stSQL);
		hmReturn	=	operateBatch(connection, hmArgData, hmArgSQL);
		throwExceptionWhenFailed(hmReturn);
	}
	/**
	* Method to insert the header details.
	*/
	public HashMap  commonParams(ArrayList arraylist2){
			HashMap hashBatchData=new HashMap();
			hashBatchData.put("item_code", (String)arraylist2.get(0));
			hashBatchData.put("store_code", (String)arraylist2.get(1));
			hashBatchData.put("trn_type", (String)arraylist2.get(2));
			hashBatchData.put("trn_qty", (String)arraylist2.get(3));
			hashBatchData.put("batch_id", (String)arraylist2.get(4));
			hashBatchData.put("expiry_date_or_receipt_date", (String)arraylist2.get(5));
			hashBatchData.put("trade_id", (String)arraylist2.get(6));
			hashBatchData.put("from_bin_location_code", (String)arraylist2.get(7));
			hashBatchData.put("release_batch_yn", "N");
			hashBatchData.put("suspended_batch_allowed_yn", (String)arraylist2.get(8));
			hashBatchData.put("login_by_id", (String)arraylist2.get(9));
			hashBatchData.put("login_at_ws_no", (String)arraylist2.get(10));
			hashBatchData.put("login_facility_id", (String)arraylist2.get(11));
			hashBatchData.put("barcode_id", checkForNull((String)arraylist2.get(12))); //04/05/12
	//Added By Sakti against CRF# - RUT-CRF-0081 icn#34757
			//hashBatchData.put("doc_type_code", checkForNull((String)arraylist2.get(13))); //08/02/13
			//hashBatchData.put("doc_no", checkForNull((String)arraylist2.get(14))); //08/02/13
			//hashBatchData.put("doc_date", checkForNull((String)arraylist2.get(15))); //08/02/13
	//Added ends
			System.out.println("hashBatchData==687==>" +hashBatchData);
		return hashBatchData;
		}
}
